#!/bin/bash
# ðŸ”’ Script de ConfiguraÃ§Ã£o SSL/TLS - Bot Hawk Esports
# ConfiguraÃ§Ã£o automÃ¡tica de certificados SSL com Let's Encrypt

set -euo pipefail

# ConfiguraÃ§Ãµes
DOMAIN=""
EMAIL=""
WEBROOT_PATH="/var/www/certbot"
CERTBOT_PATH="/etc/letsencrypt"
NGINX_CONF_PATH="./nginx/nginx.conf"
DOCKER_COMPOSE_FILE="docker-compose.prod.yml"

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# FunÃ§Ã£o de log
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_step() {
    echo -e "${PURPLE}[STEP]${NC} $1"
}

# FunÃ§Ã£o para mostrar ajuda
show_help() {
    echo "ðŸ”’ ConfiguraÃ§Ã£o SSL/TLS para Bot Hawk Esports"
    echo ""
    echo "Uso: $0 -d DOMAIN -e EMAIL [opÃ§Ãµes]"
    echo ""
    echo "OpÃ§Ãµes obrigatÃ³rias:"
    echo "  -d, --domain DOMAIN    DomÃ­nio para o certificado SSL"
    echo "  -e, --email EMAIL      Email para registro no Let's Encrypt"
    echo ""
    echo "OpÃ§Ãµes:"
    echo "  -s, --staging          Usar ambiente de teste do Let's Encrypt"
    echo "  -f, --force            ForÃ§ar renovaÃ§Ã£o do certificado"
    echo "  -h, --help             Mostrar esta ajuda"
    echo ""
    echo "Exemplos:"
    echo "  $0 -d bot.exemplo.com -e admin@exemplo.com"
    echo "  $0 -d bot.exemplo.com -e admin@exemplo.com --staging"
}

# FunÃ§Ã£o para validar parÃ¢metros
validate_params() {
    if [ -z "$DOMAIN" ]; then
        log_error "DomÃ­nio Ã© obrigatÃ³rio. Use -d ou --domain"
        show_help
        exit 1
    fi
    
    if [ -z "$EMAIL" ]; then
        log_error "Email Ã© obrigatÃ³rio. Use -e ou --email"
        show_help
        exit 1
    fi
    
    # Validar formato do email
    if ! [[ "$EMAIL" =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$ ]]; then
        log_error "Formato de email invÃ¡lido: $EMAIL"
        exit 1
    fi
    
    # Validar formato do domÃ­nio
    if ! [[ "$DOMAIN" =~ ^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]\.[a-zA-Z]{2,}$ ]]; then
        log_error "Formato de domÃ­nio invÃ¡lido: $DOMAIN"
        exit 1
    fi
}

# FunÃ§Ã£o para verificar prÃ©-requisitos
check_prerequisites() {
    log_step "Verificando prÃ©-requisitos..."
    
    # Verificar se estÃ¡ rodando como root
    if [ "$EUID" -ne 0 ]; then
        log_error "Este script deve ser executado como root"
        exit 1
    fi
    
    # Verificar Docker
    if ! command -v docker &> /dev/null; then
        log_error "Docker nÃ£o estÃ¡ instalado"
        exit 1
    fi
    
    # Verificar Docker Compose
    if ! command -v docker-compose &> /dev/null; then
        log_error "Docker Compose nÃ£o estÃ¡ instalado"
        exit 1
    fi
    
    # Verificar conectividade com Let's Encrypt
    if ! curl -s --connect-timeout 10 https://acme-v02.api.letsencrypt.org/directory > /dev/null; then
        log_error "NÃ£o foi possÃ­vel conectar ao Let's Encrypt"
        exit 1
    fi
    
    log_success "PrÃ©-requisitos verificados"
}

# FunÃ§Ã£o para criar diretÃ³rios necessÃ¡rios
create_directories() {
    log_step "Criando diretÃ³rios necessÃ¡rios..."
    
    mkdir -p "$WEBROOT_PATH"
    mkdir -p "$CERTBOT_PATH/live/$DOMAIN"
    mkdir -p "$CERTBOT_PATH/archive/$DOMAIN"
    mkdir -p "./nginx/ssl"
    
    log_success "DiretÃ³rios criados"
}

# FunÃ§Ã£o para gerar certificado temporÃ¡rio
generate_temp_certificate() {
    log_step "Gerando certificado temporÃ¡rio..."
    
    openssl req -x509 -nodes -newkey rsa:4096 \
        -days 1 \
        -keyout "./nginx/ssl/privkey.pem" \
        -out "./nginx/ssl/fullchain.pem" \
        -subj "/CN=$DOMAIN" 2>/dev/null
    
    log_success "Certificado temporÃ¡rio gerado"
}

# FunÃ§Ã£o para iniciar Nginx temporÃ¡rio
start_temp_nginx() {
    log_step "Iniciando Nginx temporÃ¡rio..."
    
    # Criar configuraÃ§Ã£o temporÃ¡ria do Nginx
    cat > ./nginx/temp-nginx.conf << EOF
events {
    worker_connections 1024;
}

http {
    server {
        listen 80;
        server_name $DOMAIN;
        
        location /.well-known/acme-challenge/ {
            root $WEBROOT_PATH;
        }
        
        location / {
            return 301 https://\$server_name\$request_uri;
        }
    }
    
    server {
        listen 443 ssl;
        server_name $DOMAIN;
        
        ssl_certificate /etc/nginx/ssl/fullchain.pem;
        ssl_certificate_key /etc/nginx/ssl/privkey.pem;
        
        location / {
            return 200 'SSL Setup in Progress';
            add_header Content-Type text/plain;
        }
    }
}
EOF
    
    # Iniciar container Nginx temporÃ¡rio
    docker run -d --name temp-nginx \
        -p 80:80 -p 443:443 \
        -v "$(pwd)/nginx/temp-nginx.conf:/etc/nginx/nginx.conf:ro" \
        -v "$(pwd)/nginx/ssl:/etc/nginx/ssl:ro" \
        -v "$WEBROOT_PATH:$WEBROOT_PATH" \
        nginx:alpine
    
    # Aguardar Nginx iniciar
    sleep 5
    
    log_success "Nginx temporÃ¡rio iniciado"
}

# FunÃ§Ã£o para obter certificado SSL
obtain_ssl_certificate() {
    log_step "Obtendo certificado SSL do Let's Encrypt..."
    
    local staging_flag=""
    if [ "${STAGING:-false}" = "true" ]; then
        staging_flag="--staging"
        log_info "Usando ambiente de teste do Let's Encrypt"
    fi
    
    local force_flag=""
    if [ "${FORCE:-false}" = "true" ]; then
        force_flag="--force-renewal"
        log_info "ForÃ§ando renovaÃ§Ã£o do certificado"
    fi
    
    # Executar certbot
    docker run --rm \
        -v "$CERTBOT_PATH:/etc/letsencrypt" \
        -v "$WEBROOT_PATH:$WEBROOT_PATH" \
        certbot/certbot certonly \
        --webroot \
        --webroot-path="$WEBROOT_PATH" \
        --email "$EMAIL" \
        --agree-tos \
        --no-eff-email \
        --domains "$DOMAIN" \
        $staging_flag \
        $force_flag
    
    if [ $? -eq 0 ]; then
        log_success "Certificado SSL obtido com sucesso"
    else
        log_error "Falha ao obter certificado SSL"
        return 1
    fi
}

# FunÃ§Ã£o para copiar certificados
copy_certificates() {
    log_step "Copiando certificados..."
    
    # Copiar certificados para o diretÃ³rio do Nginx
    cp "$CERTBOT_PATH/live/$DOMAIN/fullchain.pem" "./nginx/ssl/"
    cp "$CERTBOT_PATH/live/$DOMAIN/privkey.pem" "./nginx/ssl/"
    
    # Definir permissÃµes corretas
    chmod 644 "./nginx/ssl/fullchain.pem"
    chmod 600 "./nginx/ssl/privkey.pem"
    
    log_success "Certificados copiados"
}

# FunÃ§Ã£o para atualizar configuraÃ§Ã£o do Nginx
update_nginx_config() {
    log_step "Atualizando configuraÃ§Ã£o do Nginx..."
    
    # Backup da configuraÃ§Ã£o atual
    cp "$NGINX_CONF_PATH" "${NGINX_CONF_PATH}.backup.$(date +%Y%m%d_%H%M%S)"
    
    # Atualizar configuraÃ§Ã£o para usar SSL real
    sed -i "s|ssl_certificate /etc/nginx/ssl/.*|ssl_certificate /etc/nginx/ssl/fullchain.pem;|g" "$NGINX_CONF_PATH"
    sed -i "s|ssl_certificate_key /etc/nginx/ssl/.*|ssl_certificate_key /etc/nginx/ssl/privkey.pem;|g" "$NGINX_CONF_PATH"
    
    # Adicionar configuraÃ§Ãµes SSL seguras se nÃ£o existirem
    if ! grep -q "ssl_protocols" "$NGINX_CONF_PATH"; then
        sed -i '/ssl_certificate_key/a\    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;\n    ssl_prefer_server_ciphers off;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;' "$NGINX_CONF_PATH"
    fi
    
    log_success "ConfiguraÃ§Ã£o do Nginx atualizada"
}

# FunÃ§Ã£o para parar Nginx temporÃ¡rio
stop_temp_nginx() {
    log_step "Parando Nginx temporÃ¡rio..."
    
    docker stop temp-nginx > /dev/null 2>&1 || true
    docker rm temp-nginx > /dev/null 2>&1 || true
    rm -f ./nginx/temp-nginx.conf
    
    log_success "Nginx temporÃ¡rio removido"
}

# FunÃ§Ã£o para reiniciar serviÃ§os
restart_services() {
    log_step "Reiniciando serviÃ§os..."
    
    # Reiniciar apenas o Nginx
    docker-compose -f "$DOCKER_COMPOSE_FILE" restart nginx
    
    # Aguardar Nginx iniciar
    sleep 10
    
    log_success "ServiÃ§os reiniciados"
}

# FunÃ§Ã£o para verificar certificado
verify_certificate() {
    log_step "Verificando certificado SSL..."
    
    # Verificar se o certificado Ã© vÃ¡lido
    if openssl x509 -in "./nginx/ssl/fullchain.pem" -text -noout | grep -q "$DOMAIN"; then
        log_success "Certificado SSL vÃ¡lido para $DOMAIN"
    else
        log_error "Certificado SSL invÃ¡lido"
        return 1
    fi
    
    # Verificar conectividade HTTPS
    if curl -s --connect-timeout 10 "https://$DOMAIN" > /dev/null; then
        log_success "ConexÃ£o HTTPS funcionando"
    else
        log_warning "ConexÃ£o HTTPS pode nÃ£o estar funcionando corretamente"
    fi
    
    # Mostrar informaÃ§Ãµes do certificado
    local expiry_date=$(openssl x509 -in "./nginx/ssl/fullchain.pem" -noout -enddate | cut -d= -f2)
    log_info "Certificado expira em: $expiry_date"
}

# FunÃ§Ã£o para configurar renovaÃ§Ã£o automÃ¡tica
setup_auto_renewal() {
    log_step "Configurando renovaÃ§Ã£o automÃ¡tica..."
    
    # Criar script de renovaÃ§Ã£o
    cat > ./scripts/renew-ssl.sh << 'EOF'
#!/bin/bash
# Script de renovaÃ§Ã£o automÃ¡tica SSL

set -euo pipefail

DOMAIN="DOMAIN_PLACEHOLDER"
CERTBOT_PATH="/etc/letsencrypt"
DOCKER_COMPOSE_FILE="docker-compose.prod.yml"

# Renovar certificado
docker run --rm \
    -v "$CERTBOT_PATH:/etc/letsencrypt" \
    -v "/var/www/certbot:/var/www/certbot" \
    certbot/certbot renew --quiet

# Verificar se houve renovaÃ§Ã£o
if [ $? -eq 0 ]; then
    # Copiar novos certificados
    cp "$CERTBOT_PATH/live/$DOMAIN/fullchain.pem" "./nginx/ssl/"
    cp "$CERTBOT_PATH/live/$DOMAIN/privkey.pem" "./nginx/ssl/"
    
    # Reiniciar Nginx
    docker-compose -f "$DOCKER_COMPOSE_FILE" restart nginx
    
    echo "[$(date)] Certificado SSL renovado com sucesso"
else
    echo "[$(date)] Erro na renovaÃ§Ã£o do certificado SSL"
fi
EOF
    
    # Substituir placeholder pelo domÃ­nio real
    sed -i "s/DOMAIN_PLACEHOLDER/$DOMAIN/g" ./scripts/renew-ssl.sh
    chmod +x ./scripts/renew-ssl.sh
    
    # Adicionar ao crontab (executar diariamente Ã s 2:00)
    (crontab -l 2>/dev/null; echo "0 2 * * * $(pwd)/scripts/renew-ssl.sh >> $(pwd)/logs/ssl-renewal.log 2>&1") | crontab -
    
    log_success "RenovaÃ§Ã£o automÃ¡tica configurada (diariamente Ã s 2:00)"
}

# FunÃ§Ã£o principal
main() {
    log_info "ðŸ”’ Iniciando configuraÃ§Ã£o SSL/TLS para $DOMAIN"
    
    # Verificar prÃ©-requisitos
    check_prerequisites
    
    # Criar diretÃ³rios
    create_directories
    
    # Gerar certificado temporÃ¡rio
    generate_temp_certificate
    
    # Iniciar Nginx temporÃ¡rio
    start_temp_nginx
    
    # Obter certificado real
    if obtain_ssl_certificate; then
        copy_certificates
        update_nginx_config
    else
        log_error "Falha ao obter certificado SSL"
        stop_temp_nginx
        exit 1
    fi
    
    # Parar Nginx temporÃ¡rio
    stop_temp_nginx
    
    # Reiniciar serviÃ§os
    restart_services
    
    # Verificar certificado
    verify_certificate
    
    # Configurar renovaÃ§Ã£o automÃ¡tica
    setup_auto_renewal
    
    log_success "ðŸŽ‰ ConfiguraÃ§Ã£o SSL/TLS concluÃ­da com sucesso!"
    log_info "Seu bot agora estÃ¡ acessÃ­vel via HTTPS em: https://$DOMAIN"
}

# Processar argumentos da linha de comando
while [[ $# -gt 0 ]]; do
    case $1 in
        -d|--domain)
            DOMAIN="$2"
            shift 2
            ;;
        -e|--email)
            EMAIL="$2"
            shift 2
            ;;
        -s|--staging)
            STAGING="true"
            shift
            ;;
        -f|--force)
            FORCE="true"
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            log_error "OpÃ§Ã£o desconhecida: $1"
            show_help
            exit 1
            ;;
    esac
done

# Validar parÃ¢metros
validate_params

# Tratamento de erros
trap 'log_error "ConfiguraÃ§Ã£o SSL falhou na linha $LINENO"; stop_temp_nginx; exit 1' ERR

# Executar configuraÃ§Ã£o
main "$@"