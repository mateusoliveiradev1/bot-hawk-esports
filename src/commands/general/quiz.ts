import {
  SlashCommandBuilder,
  EmbedBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  ComponentType,
  ChatInputCommandInteraction,
  MessageFlags,
} from 'discord.js';
import { Command, CommandCategory } from '../../types/command';
import { ExtendedClient } from '../../types/client';
import { Logger } from '../../utils/logger';
import { GameService, QuizSettings } from '../../services/game.service';
import { DatabaseService } from '../../database/database.service';

/**
 * Quiz command - Interactive PUBG and gaming quizzes
 */
const quiz: Command = {
  data: new SlashCommandBuilder()
    .setName('quiz')
    .setDescription('üß† Inicia um quiz interativo sobre PUBG e gaming')
    .addStringOption(option =>
      option
        .setName('category')
        .setDescription('Categoria do quiz')
        .setRequired(false)
        .addChoices(
          { name: 'üéÆ PUBG', value: 'pubg' },
          { name: 'üéØ Gaming Geral', value: 'gaming' },
          { name: 'üèÜ Esports', value: 'esports' },
          { name: 'üé≤ Misto', value: 'mixed' },
        ),
    )
    .addStringOption(option =>
      option
        .setName('difficulty')
        .setDescription('Dificuldade do quiz')
        .setRequired(false)
        .addChoices(
          { name: 'üü¢ F√°cil', value: 'easy' },
          { name: 'üü° M√©dio', value: 'medium' },
          { name: 'üî¥ Dif√≠cil', value: 'hard' },
          { name: 'üåà Misto', value: 'mixed' },
        ),
    )
    .addIntegerOption(option =>
      option
        .setName('questions')
        .setDescription('N√∫mero de perguntas (5-20)')
        .setRequired(false)
        .setMinValue(5)
        .setMaxValue(20),
    )
    .addIntegerOption(option =>
      option
        .setName('time')
        .setDescription('Tempo por pergunta em segundos (15-120)')
        .setRequired(false)
        .setMinValue(15)
        .setMaxValue(120),
    ) as SlashCommandBuilder,

  category: CommandCategory.GENERAL,
  cooldown: 30,

  async execute(interaction: any, client: ExtendedClient) {
    const logger = new Logger();
    const gameService = new GameService(client);
    const database = new DatabaseService();

    try {
      // Get options
      const category = interaction.options.getString('category') || 'pubg';
      const difficulty = interaction.options.getString('difficulty') || 'mixed';
      const questionCount = interaction.options.getInteger('questions') || 10;
      const timePerQuestion = interaction.options.getInteger('time') || 30;

      // Check if user is registered
      const user = await database.client.user.findUnique({
        where: { id: interaction.user.id },
      });

      if (!user) {
        const embed = new EmbedBuilder()
          .setTitle('‚ùå Usu√°rio N√£o Registrado')
          .setDescription(
            'Voc√™ precisa se registrar primeiro usando `/register` para participar de quizzes!',
          )
          .setColor(0xff0000)
          .setTimestamp();

        return interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
      }

      // Check if there's already an active quiz in this channel
      const existingSession = gameService.getQuizSession(
        `${interaction.guildId}_${interaction.channelId}`,
      );
      if (existingSession && existingSession.isActive) {
        const embed = new EmbedBuilder()
          .setTitle('‚ö†Ô∏è Quiz J√° Ativo')
          .setDescription(
            'J√° existe um quiz ativo neste canal! Aguarde ele terminar ou participe dele.',
          )
          .setColor(0xffa500)
          .setTimestamp();

        return interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
      }

      // Create quiz settings
      const settings: QuizSettings = {
        questionCount,
        timePerQuestion,
        category: category as any,
        difficulty: difficulty as any,
        allowMultipleAttempts: false,
        showCorrectAnswer: true,
      };

      // Start quiz session
      const session = await gameService.startQuiz(
        interaction.guildId!,
        interaction.channelId,
        interaction.user.id,
        settings,
      );

      // Create initial embed
      const embed = new EmbedBuilder()
        .setTitle('üß† Quiz Iniciado!')
        .setDescription(
          `**Categoria:** ${getCategoryName(category)}\n` +
            `**Dificuldade:** ${getDifficultyName(difficulty)}\n` +
            `**Perguntas:** ${questionCount}\n` +
            `**Tempo por pergunta:** ${timePerQuestion}s\n\n` +
            'üéØ **Como participar:**\n' +
            '‚Ä¢ Clique em "Participar" para entrar no quiz\n' +
            '‚Ä¢ Responda as perguntas usando os bot√µes\n' +
            '‚Ä¢ Ganhe XP e moedas baseado na sua performance!\n\n' +
            '‚è∞ O quiz come√ßar√° em 30 segundos...',
        )
        .setColor(0x0099ff)
        .setFooter({ text: `Host: ${interaction.user.username}` })
        .setTimestamp();

      const joinButton = new ActionRowBuilder<ButtonBuilder>().addComponents(
        new ButtonBuilder()
          .setCustomId(`quiz_join_${session.id}`)
          .setLabel('üéØ Participar')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId(`quiz_info_${session.id}`)
          .setLabel('‚ÑπÔ∏è Informa√ß√µes')
          .setStyle(ButtonStyle.Secondary),
      );

      const response = await interaction.reply({
        embeds: [embed],
        components: [joinButton],
      });

      // Auto-join the host
      await gameService.joinQuiz(session.id, interaction.user.id, interaction.user.username);

      // Set up button collector for joining
      const collector = response.createMessageComponentCollector({
        componentType: ComponentType.Button,
        time: 30000, // 30 seconds to join
      });

      collector.on('collect', async (buttonInteraction: any) => {
        if (buttonInteraction.customId === `quiz_join_${session.id}`) {
          const joined = await gameService.joinQuiz(
            session.id,
            buttonInteraction.user.id,
            buttonInteraction.user.username,
          );

          if (joined) {
            await buttonInteraction.reply({
              content: '‚úÖ Voc√™ entrou no quiz! Prepare-se para as perguntas.',
              flags: MessageFlags.Ephemeral,
            });
          } else {
            await buttonInteraction.reply({
              content: '‚ùå N√£o foi poss√≠vel entrar no quiz. Voc√™ j√° pode estar participando.',
              flags: MessageFlags.Ephemeral,
            });
          }
        } else if (buttonInteraction.customId === `quiz_info_${session.id}`) {
          const infoEmbed = new EmbedBuilder()
            .setTitle('‚ÑπÔ∏è Informa√ß√µes do Quiz')
            .setDescription(
              '**Sistema de Pontua√ß√£o:**\n' +
                '‚Ä¢ Resposta correta: +pontos base\n' +
                '‚Ä¢ Streak bonus: +25% por resposta consecutiva\n' +
                '‚Ä¢ Tempo bonus: +10% se responder em <50% do tempo\n\n' +
                '**Recompensas:**\n' +
                '‚Ä¢ 1¬∫ lugar: 100 XP + 50 moedas\n' +
                '‚Ä¢ 2¬∫ lugar: 75 XP + 35 moedas\n' +
                '‚Ä¢ 3¬∫ lugar: 50 XP + 25 moedas\n' +
                '‚Ä¢ Participa√ß√£o: 25 XP + 10 moedas\n\n' +
                '**Dificuldades:**\n' +
                '‚Ä¢ üü¢ F√°cil: 10 pontos\n' +
                '‚Ä¢ üü° M√©dio: 15 pontos\n' +
                '‚Ä¢ üî¥ Dif√≠cil: 20 pontos',
            )
            .setColor(0x0099ff)
            .setTimestamp();

          await buttonInteraction.reply({ embeds: [infoEmbed], flags: MessageFlags.Ephemeral });
        }
      });

      // Start the quiz after 30 seconds
      setTimeout(async () => {
        collector.stop();
        await startQuizQuestions(interaction, session, gameService);
      }, 30000);
    } catch (error) {
      logger.error('Error in quiz command:', error);

      const errorEmbed = new EmbedBuilder()
        .setTitle('‚ùå Erro')
        .setDescription('Ocorreu um erro ao iniciar o quiz. Tente novamente.')
        .setColor(0xff0000)
        .setTimestamp();

      if (interaction.replied || interaction.deferred) {
        await interaction.followUp({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
      } else {
        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
      }
    }
  },
};

/**
 * Start quiz questions
 */
async function startQuizQuestions(
  interaction: ChatInputCommandInteraction,
  session: any,
  gameService: GameService,
) {
  const currentQuestion = session.questions[session.currentQuestionIndex];

  if (!currentQuestion) {
    await endQuiz(interaction, session, gameService);
    return;
  }

  const embed = new EmbedBuilder()
    .setTitle(`üß† Pergunta ${session.currentQuestionIndex + 1}/${session.questions.length}`)
    .setDescription(
      `**${currentQuestion.question}**\n\n` +
        currentQuestion.options
          .map((option: string, index: number) => `${['üÖ∞Ô∏è', 'üÖ±Ô∏è', 'üÖ≤Ô∏è', 'üÖ≥Ô∏è'][index]} ${option}`)
          .join('\n'),
    )
    .setColor(getDifficultyColor(currentQuestion.difficulty))
    .setFooter({
      text: `‚è∞ ${currentQuestion.timeLimit}s ‚Ä¢ üíé ${currentQuestion.points} pontos ‚Ä¢ Participantes: ${session.participants.size}`,
    })
    .setTimestamp();

  const answerButtons = new ActionRowBuilder<ButtonBuilder>().addComponents(
    ...currentQuestion.options.slice(0, 4).map((_: string, index: number) =>
      new ButtonBuilder()
        .setCustomId(`quiz_answer_${session.id}_${index}`)
        .setLabel(['üÖ∞Ô∏è', 'üÖ±Ô∏è', 'üÖ≤Ô∏è', 'üÖ≥Ô∏è'][index] || `Op√ß√£o ${index + 1}`)
        .setStyle(ButtonStyle.Secondary),
    ),
  );

  const response = await interaction.editReply({
    embeds: [embed],
    components: [answerButtons],
  });

  // Set up answer collector
  const collector = response.createMessageComponentCollector({
    componentType: ComponentType.Button,
    time: currentQuestion.timeLimit * 1000,
  });

  const answeredUsers = new Set<string>();

  collector.on('collect', async buttonInteraction => {
    if (answeredUsers.has(buttonInteraction.user.id)) {
      await buttonInteraction.reply({
        content: '‚ùå Voc√™ j√° respondeu esta pergunta!',
        flags: MessageFlags.Ephemeral,
      });
      return;
    }

    const answerIndex = parseInt(buttonInteraction.customId.split('_')[3] || '0');
    const result = await gameService.submitQuizAnswer(
      session.id,
      buttonInteraction.user.id,
      answerIndex,
    );

    if (result) {
      answeredUsers.add(buttonInteraction.user.id);

      const emoji = result.correct ? '‚úÖ' : '‚ùå';
      const streakText = result.streak > 1 ? ` (üî• ${result.streak}x streak!)` : '';

      await buttonInteraction.reply({
        content: `${emoji} ${result.correct ? 'Correto' : 'Incorreto'}! +${result.points} pontos${streakText}`,
        flags: MessageFlags.Ephemeral,
      });
    }
  });

  collector.on('end', async () => {
    // Show correct answer
    const correctEmbed = new EmbedBuilder()
      .setTitle('‚úÖ Resposta Correta')
      .setDescription(
        `**${currentQuestion.question}**\n\n` +
          `**Resposta:** ${['üÖ∞Ô∏è', 'üÖ±Ô∏è', 'üÖ≤Ô∏è', 'üÖ≥Ô∏è'][currentQuestion.correctAnswer]} ${currentQuestion.options[currentQuestion.correctAnswer]}`,
      )
      .setColor(0x00ff00)
      .setTimestamp();

    await interaction.editReply({
      embeds: [correctEmbed],
      components: [],
    });

    // Move to next question after 3 seconds
    setTimeout(async () => {
      session.currentQuestionIndex++;
      await startQuizQuestions(interaction, session, gameService);
    }, 3000);
  });
}

/**
 * End quiz and show results
 */
async function endQuiz(
  interaction: ChatInputCommandInteraction,
  session: any,
  gameService: GameService,
) {
  const results = await gameService.endQuiz(session.id);

  if (results.length === 0) {
    const embed = new EmbedBuilder()
      .setTitle('üèÅ Quiz Finalizado')
      .setDescription('Nenhum participante completou o quiz.')
      .setColor(0xffa500)
      .setTimestamp();

    await interaction.editReply({ embeds: [embed], components: [] });
    return;
  }

  // Sort by score
  results.sort((a, b) => b.score - a.score);

  const embed = new EmbedBuilder()
    .setTitle('üèÜ Resultados do Quiz')
    .setDescription(
      results
        .slice(0, 10)
        .map((participant, index) => {
          const medal = ['ü•á', 'ü•à', 'ü•â'][index] || `${index + 1}¬∫`;
          const accuracy =
            participant.totalAnswers > 0
              ? Math.round((participant.correctAnswers / participant.totalAnswers) * 100)
              : 0;

          return (
            `${medal} **${participant.username}**\n` +
            `üìä ${participant.score} pontos ‚Ä¢ ‚úÖ ${participant.correctAnswers}/${participant.totalAnswers} (${accuracy}%)`
          );
        })
        .join('\n\n'),
    )
    .setColor(0xffd700)
    .setFooter({ text: `Participantes: ${results.length}` })
    .setTimestamp();

  await interaction.editReply({ embeds: [embed], components: [] });
}

/**
 * Helper functions
 */
function getCategoryName(category: string): string {
  const names = {
    pubg: 'üéÆ PUBG',
    gaming: 'üéØ Gaming Geral',
    esports: 'üèÜ Esports',
    mixed: 'üé≤ Misto',
  };
  return names[category as keyof typeof names] || 'üé≤ Misto';
}

function getDifficultyName(difficulty: string): string {
  const names = {
    easy: 'üü¢ F√°cil',
    medium: 'üü° M√©dio',
    hard: 'üî¥ Dif√≠cil',
    mixed: 'üåà Misto',
  };
  return names[difficulty as keyof typeof names] || 'üåà Misto';
}

function getDifficultyColor(difficulty: string): number {
  const colors = {
    easy: 0x00ff00,
    medium: 0xffa500,
    hard: 0xff0000,
  };
  return colors[difficulty as keyof typeof colors] || 0x0099ff;
}

export default quiz;
