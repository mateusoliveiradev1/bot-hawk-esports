import {
  SlashCommandBuilder,
  ChatInputCommandInteraction,
  EmbedBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  ModalBuilder,
  TextInputBuilder,
  TextInputStyle,
  PermissionFlagsBits,
  ComponentType,
} from 'discord.js';
import { Command } from '../../types/command';
import { ExtendedClient } from '../../types/client';
import { Logger } from '../../utils/logger';

const logger = new Logger();

export default {
  category: 'general',
  data: new SlashCommandBuilder()
    .setName('ticket')
    .setDescription('Sistema de tickets para suporte')
    .addSubcommand(subcommand =>
      subcommand
        .setName('create')
        .setDescription('Criar um novo ticket')
        .addStringOption(option =>
          option
            .setName('assunto')
            .setDescription('Assunto do ticket')
            .setRequired(true)
            .setMaxLength(100)
        )
        .addStringOption(option =>
          option
            .setName('descricao')
            .setDescription('Descri√ß√£o detalhada do problema')
            .setRequired(true)
            .setMaxLength(1000)
        )
        .addStringOption(option =>
          option
            .setName('prioridade')
            .setDescription('Prioridade do ticket')
            .setRequired(false)
            .addChoices(
              { name: 'üü¢ Baixa', value: 'low' },
              { name: 'üü° M√©dia', value: 'medium' },
              { name: 'üü† Alta', value: 'high' },
              { name: 'üî¥ Urgente', value: 'urgent' }
            )
        )
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('list')
        .setDescription('Listar seus tickets')
        .addStringOption(option =>
          option
            .setName('status')
            .setDescription('Filtrar por status')
            .setRequired(false)
            .addChoices(
              { name: 'Abertos', value: 'open' },
              { name: 'Em andamento', value: 'in_progress' },
              { name: 'Fechados', value: 'closed' }
            )
        )
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('close')
        .setDescription('Fechar um ticket')
        .addStringOption(option =>
          option.setName('ticket_id').setDescription('ID do ticket para fechar').setRequired(true)
        )
        .addStringOption(option =>
          option
            .setName('motivo')
            .setDescription('Motivo para fechar o ticket')
            .setRequired(false)
            .setMaxLength(500)
        )
    )
    .addSubcommand(subcommand =>
      subcommand.setName('panel').setDescription('Criar painel de tickets (Admin apenas)')
    )
    .addSubcommand(subcommand =>
      subcommand.setName('stats').setDescription('Estat√≠sticas de tickets (Admin apenas)')
    ),

  async execute(interaction: ChatInputCommandInteraction, client: ExtendedClient) {
    try {
      const subcommand = interaction.options.getSubcommand();
      const ticketService = client.services?.ticket;

      if (!ticketService) {
        const errorEmbed = new EmbedBuilder()
          .setTitle('‚ùå Erro')
          .setDescription('Servi√ßo de tickets n√£o est√° dispon√≠vel.')
          .setColor('#FF0000');

        await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
        return;
      }

      switch (subcommand) {
        case 'create':
          await handleCreateTicket(interaction, ticketService);
          break;
        case 'list':
          await handleListTickets(interaction, ticketService);
          break;
        case 'close':
          await handleCloseTicket(interaction, ticketService);
          break;
        case 'panel':
          await handleCreatePanel(interaction, ticketService);
          break;
        case 'stats':
          await handleTicketStats(interaction, ticketService);
          break;
        default:
          await interaction.reply({ content: 'Subcomando n√£o reconhecido.', ephemeral: true });
      }
    } catch (error) {
      logger.error('Error in ticket command:', error);

      const errorEmbed = new EmbedBuilder()
        .setTitle('‚ùå Erro')
        .setDescription('Ocorreu um erro ao processar o comando.')
        .setColor('#FF0000');

      if (interaction.replied || interaction.deferred) {
        await interaction.editReply({ embeds: [errorEmbed] });
      } else {
        await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
      }
    }
  },
} as Command;

/**
 * Handle create ticket subcommand
 */
async function handleCreateTicket(interaction: ChatInputCommandInteraction, ticketService: any) {
  const assunto = interaction.options.getString('assunto', true);
  const descricao = interaction.options.getString('descricao', true);
  const prioridade =
    (interaction.options.getString('prioridade') as 'low' | 'medium' | 'high' | 'urgent') ||
    'medium';

  await interaction.deferReply({ ephemeral: true });

  const result = await ticketService.createTicket(
    interaction.guildId!,
    interaction.user.id,
    assunto,
    descricao,
    prioridade
  );

  if (result.success) {
    const successEmbed = new EmbedBuilder()
      .setTitle('‚úÖ Ticket Criado!')
      .setDescription(
        `Seu ticket foi criado com sucesso!\n\n**Canal:** ${result.channel}\n**ID:** #${result.ticket!.id.slice(-8)}`
      )
      .setColor('#00FF00')
      .addFields(
        { name: 'üìù Assunto', value: assunto, inline: true },
        { name: 'üìä Prioridade', value: prioridade.toUpperCase(), inline: true },
        { name: '‚è∞ Criado em', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: false }
      )
      .setFooter({ text: 'Nossa equipe ir√° atend√™-lo em breve!' });

    await interaction.editReply({ embeds: [successEmbed] });
  } else {
    const errorEmbed = new EmbedBuilder()
      .setTitle('‚ùå Erro ao Criar Ticket')
      .setDescription(result.message)
      .setColor('#FF0000');

    await interaction.editReply({ embeds: [errorEmbed] });
  }
}

/**
 * Handle list tickets subcommand
 */
async function handleListTickets(interaction: ChatInputCommandInteraction, ticketService: any) {
  const status = interaction.options.getString('status') as
    | 'open'
    | 'in_progress'
    | 'closed'
    | null;

  await interaction.deferReply({ ephemeral: true });

  const userTickets = ticketService.getUserTickets(interaction.guildId!, interaction.user.id);
  let filteredTickets = userTickets;

  if (status) {
    filteredTickets = userTickets.filter((ticket: any) => ticket.status === status);
  }

  if (filteredTickets.length === 0) {
    const noTicketsEmbed = new EmbedBuilder()
      .setTitle('üìã Seus Tickets')
      .setDescription(
        status ? `Voc√™ n√£o possui tickets com status "${status}".` : 'Voc√™ n√£o possui tickets.'
      )
      .setColor('#FFA500')
      .setFooter({ text: 'Use /ticket create para criar um novo ticket' });

    await interaction.editReply({ embeds: [noTicketsEmbed] });
    return;
  }

  const statusEmojis = {
    open: 'üü¢',
    in_progress: 'üü°',
    closed: 'üî¥',
  };

  const priorityEmojis = {
    low: 'üü¢',
    medium: 'üü°',
    high: 'üü†',
    urgent: 'üî¥',
  };

  const ticketList = filteredTickets
    .map((ticket: any) => {
      const statusEmoji = statusEmojis[ticket.status as keyof typeof statusEmojis];
      const priorityEmoji = priorityEmojis[ticket.priority as keyof typeof priorityEmojis];
      const channelMention = ticket.channelId ? `<#${ticket.channelId}>` : 'Canal removido';

      return (
        `${statusEmoji} **#${ticket.id.slice(-8)}** - ${ticket.title}\n` +
        `${priorityEmoji} ${ticket.priority.toUpperCase()} | ${channelMention}\n` +
        `üìÖ <t:${Math.floor(ticket.createdAt.getTime() / 1000)}:R>`
      );
    })
    .join('\n\n');

  const listEmbed = new EmbedBuilder()
    .setTitle('üìã Seus Tickets')
    .setDescription(ticketList)
    .setColor('#0099FF')
    .setFooter({ text: `Total: ${filteredTickets.length} ticket(s)` });

  await interaction.editReply({ embeds: [listEmbed] });
}

/**
 * Handle close ticket subcommand
 */
async function handleCloseTicket(interaction: ChatInputCommandInteraction, ticketService: any) {
  const ticketId = interaction.options.getString('ticket_id', true);
  const motivo = interaction.options.getString('motivo') || 'N√£o especificado';

  await interaction.deferReply({ ephemeral: true });

  // Check if user owns the ticket or has permission to close it
  const ticket = ticketService.getTicketData(interaction.guildId!, ticketId);
  if (!ticket) {
    const errorEmbed = new EmbedBuilder()
      .setTitle('‚ùå Ticket N√£o Encontrado')
      .setDescription('O ticket especificado n√£o foi encontrado.')
      .setColor('#FF0000');

    await interaction.editReply({ embeds: [errorEmbed] });
    return;
  }

  // Check permissions
  const member = interaction.member;
  const canClose =
    ticket.userId === interaction.user.id ||
    (member &&
      'permissions' in member &&
      typeof member.permissions !== 'string' &&
      member.permissions.has(PermissionFlagsBits.ManageMessages));

  if (!canClose) {
    const errorEmbed = new EmbedBuilder()
      .setTitle('‚ùå Sem Permiss√£o')
      .setDescription(
        'Voc√™ s√≥ pode fechar seus pr√≥prios tickets ou precisa ter permiss√£o de modera√ß√£o.'
      )
      .setColor('#FF0000');

    await interaction.editReply({ embeds: [errorEmbed] });
    return;
  }

  const result = await ticketService.closeTicket(
    interaction.guildId!,
    ticketId,
    interaction.user.id,
    motivo
  );

  if (result.success) {
    const successEmbed = new EmbedBuilder()
      .setTitle('‚úÖ Ticket Fechado')
      .setDescription(`Ticket #${ticketId.slice(-8)} foi fechado com sucesso.`)
      .setColor('#00FF00')
      .addFields(
        { name: 'üìù Motivo', value: motivo, inline: false },
        { name: 'üë§ Fechado por', value: interaction.user.tag, inline: true },
        { name: '‚è∞ Fechado em', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true }
      );

    await interaction.editReply({ embeds: [successEmbed] });
  } else {
    const errorEmbed = new EmbedBuilder()
      .setTitle('‚ùå Erro ao Fechar Ticket')
      .setDescription(result.message)
      .setColor('#FF0000');

    await interaction.editReply({ embeds: [errorEmbed] });
  }
}

/**
 * Handle create panel subcommand
 */
async function handleCreatePanel(interaction: ChatInputCommandInteraction, ticketService: any) {
  // Check permissions
  const member = interaction.member;
  if (
    !member ||
    !('permissions' in member) ||
    typeof member.permissions === 'string' ||
    !member.permissions.has(PermissionFlagsBits.ManageGuild)
  ) {
    const errorEmbed = new EmbedBuilder()
      .setTitle('‚ùå Sem Permiss√£o')
      .setDescription(
        'Voc√™ precisa ter permiss√£o de "Gerenciar Servidor" para criar pain√©is de ticket.'
      )
      .setColor('#FF0000');

    await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
    return;
  }

  const panelEmbed = new EmbedBuilder()
    .setTitle('üé´ Sistema de Tickets')
    .setDescription(
      '**Precisa de ajuda?** Crie um ticket e nossa equipe ir√° atend√™-lo!\n\n' +
        '**Como funciona:**\n' +
        '‚Ä¢ Clique no bot√£o abaixo para criar um ticket\n' +
        '‚Ä¢ Descreva seu problema ou d√∫vida\n' +
        '‚Ä¢ Nossa equipe ir√° responder em breve\n' +
        '‚Ä¢ O ticket ser√° fechado quando resolvido\n\n' +
        '**Tipos de suporte:**\n' +
        'üü¢ **D√∫vidas gerais** - Perguntas sobre o servidor\n' +
        'üü° **Problemas t√©cnicos** - Bugs ou erros\n' +
        'üü† **Den√∫ncias** - Reportar comportamento inadequado\n' +
        'üî¥ **Urgente** - Problemas cr√≠ticos que precisam de aten√ß√£o imediata'
    )
    .setColor('#0099FF')
    .setThumbnail(interaction.guild?.iconURL() || null)
    .setFooter({ text: 'Clique no bot√£o abaixo para criar um ticket' });

  const row = new ActionRowBuilder<ButtonBuilder>().addComponents(
    new ButtonBuilder()
      .setCustomId('create_ticket_panel')
      .setLabel('Criar Ticket')
      .setStyle(ButtonStyle.Primary)
      .setEmoji('üé´')
  );

  await interaction.reply({ embeds: [panelEmbed], components: [row] });
}

/**
 * Handle ticket stats subcommand
 */
async function handleTicketStats(interaction: ChatInputCommandInteraction, ticketService: any) {
  // Check permissions
  const member = interaction.member;
  if (
    !member ||
    !('permissions' in member) ||
    typeof member.permissions === 'string' ||
    !member.permissions.has(PermissionFlagsBits.ManageMessages)
  ) {
    const errorEmbed = new EmbedBuilder()
      .setTitle('‚ùå Sem Permiss√£o')
      .setDescription('Voc√™ precisa ter permiss√£o de modera√ß√£o para ver estat√≠sticas de tickets.')
      .setColor('#FF0000');

    await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
    return;
  }

  await interaction.deferReply({ ephemeral: true });

  const stats = await ticketService.getTicketStats(interaction.guildId!);

  const statsEmbed = new EmbedBuilder()
    .setTitle('üìä Estat√≠sticas de Tickets')
    .setColor('#0099FF')
    .addFields(
      { name: 'üìã Total de Tickets', value: stats.total.toString(), inline: true },
      { name: 'üü¢ Abertos', value: stats.open.toString(), inline: true },
      { name: 'üü° Em Andamento', value: stats.inProgress.toString(), inline: true },
      { name: 'üî¥ Fechados', value: stats.closed.toString(), inline: true },
      { name: '‚è±Ô∏è Tempo M√©dio de Resposta', value: `${stats.avgResponseTime} min`, inline: true },
      { name: 'üèÅ Tempo M√©dio de Resolu√ß√£o', value: `${stats.avgResolutionTime} min`, inline: true }
    )
    .setFooter({ text: 'Estat√≠sticas do servidor atual' })
    .setTimestamp();

  await interaction.editReply({ embeds: [statsEmbed] });
}
