import {
  SlashCommandBuilder,
  EmbedBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  MessageFlags,
} from 'discord.js';
import { Command, CommandCategory } from '../../types/command';
import { ExtendedClient } from '../../types/client';
import { Logger } from '../../utils/logger';
import { MusicService } from '../../services/music.service';

/**
 * Play command - Plays music from YouTube or Spotify
 */
const play: Command = {
  data: new SlashCommandBuilder()
    .setName('play')
    .setDescription('üéµ Toca uma m√∫sica ou playlist')
    .addStringOption(option =>
      option
        .setName('query')
        .setDescription('Nome da m√∫sica, URL do YouTube/Spotify ou termo de busca')
        .setRequired(true),
    )
    .addBooleanOption(option =>
      option
        .setName('shuffle')
        .setDescription('Embaralhar a playlist (padr√£o: false)')
        .setRequired(false),
    )
    .addBooleanOption(option =>
      option
        .setName('next')
        .setDescription('Adicionar no in√≠cio da fila (padr√£o: false)')
        .setRequired(false),
    ) as SlashCommandBuilder,

  category: CommandCategory.MUSIC,
  cooldown: 3,

  async execute(interaction, client: ExtendedClient) {
    const logger = new Logger();
    const musicService = new MusicService();

    const query = (interaction as any).options?.getString('query', true);
    const shuffle = (interaction as any).options?.getBoolean('shuffle') || false;
    const playNext = (interaction as any).options?.getBoolean('next') || false;

    try {
      // Check if user is in a voice channel
      const member = interaction.member as any;
      if (!member?.voice?.channel) {
        const errorEmbed = new EmbedBuilder()
          .setTitle('‚ùå Erro')
          .setDescription('Voc√™ precisa estar em um canal de voz para tocar m√∫sica!')
          .setColor('#FF0000');

        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
        return;
      }

      const voiceChannel = member.voice.channel;

      // Check bot permissions
      const permissions = voiceChannel.permissionsFor(client.user!);
      if (!permissions?.has(['Connect', 'Speak'])) {
        const errorEmbed = new EmbedBuilder()
          .setTitle('‚ùå Sem Permiss√µes')
          .setDescription('N√£o tenho permiss√£o para conectar ou falar neste canal de voz!')
          .setColor('#FF0000');

        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
        return;
      }

      await interaction.deferReply();

      // Search for tracks using the proper method
      logger.debug(`üîç Searching for: "${query}"`);

      let tracks: any[] = [];

      // Use the addTrack method which handles both YouTube and Spotify
      const result = await musicService.addTrack(interaction.guildId!, query, interaction.user.id);

      if (!result.success || !result.track) {
        const notFoundEmbed = new EmbedBuilder()
          .setTitle('‚ùå Nenhuma m√∫sica encontrada')
          .setDescription(
            `N√£o foi poss√≠vel encontrar resultados para: **${query}**\n\nTente:\n‚Ä¢ Verificar a ortografia\n‚Ä¢ Usar termos mais espec√≠ficos\n‚Ä¢ Usar um link direto do YouTube/Spotify`,
          )
          .setColor('#FF0000');

        await interaction.editReply({ embeds: [notFoundEmbed] });
        return;
      }

      tracks = [result.track];
      logger.debug(`‚úÖ Found track: ${result.track.title} by ${result.track.artist}`);

      const isPlaylist = tracks.length > 1;

      // Join voice channel
      logger.debug(`üîó Joining voice channel: ${voiceChannel.name}`);
      const connection = await musicService.joinChannel(voiceChannel);
      if (!connection) {
        const errorEmbed = new EmbedBuilder()
          .setTitle('‚ùå Erro')
          .setDescription('N√£o foi poss√≠vel conectar ao canal de voz.')
          .setColor('#FF0000');
        await interaction.editReply({ embeds: [errorEmbed] });
        return;
      }

      // Get current queue state
      const queue = await musicService.getQueue(interaction.guildId!);
      const wasEmpty = !queue || (!queue.currentTrack && queue.tracks.length <= 1);

      logger.debug(
        `üìä Queue state: wasEmpty=${wasEmpty}, currentTrack=${queue?.currentTrack?.title || 'none'}, queueLength=${queue?.tracks.length || 0}`,
      );

      // The track was already added to queue by addTrack method
      const addedTracks = tracks;

      // Start playing if queue was empty or not currently playing
      if (wasEmpty || !queue?.isPlaying) {
        logger.debug('‚ñ∂Ô∏è Starting playback...');
        const playResult = await musicService.playNext(interaction.guildId!);
        if (!playResult) {
          logger.error('‚ùå Failed to start playback');
        } else {
          logger.debug('‚úÖ Playback started successfully');
        }
      }

      // Create response embed
      let embed: EmbedBuilder;

      if (isPlaylist) {
        embed = new EmbedBuilder()
          .setTitle('üìã Playlist Adicionada')
          .setDescription(
            `**${addedTracks.length}** m√∫sicas foram adicionadas √† fila${shuffle ? ' (embaralhadas)' : ''}!`,
          )
          .setColor('#00FF00')
          .addFields(
            {
              name: 'üéµ Primeira M√∫sica',
              value: `**${addedTracks[0]?.title}**\n${addedTracks[0]?.artist}`,
              inline: true,
            },
            {
              name: '‚è±Ô∏è Dura√ß√£o Total',
              value: formatDuration(
                addedTracks.reduce((total, track) => total + track.duration, 0),
              ),
              inline: true,
            },
            { name: 'üë§ Solicitado por', value: `<@${interaction.user.id}>`, inline: true },
          )
          .setThumbnail(addedTracks[0]?.thumbnail || '')
          .setTimestamp();
      } else {
        const track = addedTracks[0];
        const isNowPlaying = wasEmpty || !queue?.isPlaying;

        embed = new EmbedBuilder()
          .setTitle(isNowPlaying ? 'üéµ Tocando Agora' : 'üìã Adicionado √† Fila')
          .setDescription(track ? `**${track.title}**\n${track.artist}` : 'M√∫sica n√£o encontrada')
          .setColor(isNowPlaying ? '#00FF00' : '#0099FF')
          .setTimestamp();

        if (track) {
          embed
            .addFields(
              { name: '‚è±Ô∏è Dura√ß√£o', value: formatDuration(track.duration), inline: true },
              { name: 'üë§ Solicitado por', value: `<@${interaction.user.id}>`, inline: true },
              {
                name: 'üîó Fonte',
                value: track.platform === 'youtube' ? 'YouTube' : 'Spotify',
                inline: true,
              },
            )
            .setThumbnail(track.thumbnail || '');

          if (!isNowPlaying && queue) {
            const queuePosition = queue.tracks.length;
            embed.addFields({
              name: 'üìç Posi√ß√£o na Fila',
              value: `#${queuePosition}`,
              inline: true,
            });
          }
        }
      }

      // Add queue info
      const currentQueue = await musicService.getQueue(interaction.guildId!);
      if (currentQueue && currentQueue.tracks.length > 1) {
        const remainingTracks = currentQueue.tracks.length - 1;
        const totalDuration = currentQueue.tracks
          .slice(1)
          .reduce((total, track) => total + track.duration, 0);
        embed.addFields({
          name: 'üìä Fila',
          value: `${remainingTracks} m√∫sica${remainingTracks !== 1 ? 's' : ''} ‚Ä¢ ${formatDuration(totalDuration)}`,
          inline: false,
        });
      }

      // Create control buttons
      const buttonsRow = new ActionRowBuilder<ButtonBuilder>().addComponents(
        new ButtonBuilder()
          .setCustomId('music_pause')
          .setLabel('Pausar')
          .setStyle(ButtonStyle.Secondary)
          .setEmoji('‚è∏Ô∏è'),
        new ButtonBuilder()
          .setCustomId('music_skip')
          .setLabel('Pular')
          .setStyle(ButtonStyle.Primary)
          .setEmoji('‚è≠Ô∏è'),
        new ButtonBuilder()
          .setCustomId('music_queue')
          .setLabel('Fila')
          .setStyle(ButtonStyle.Secondary)
          .setEmoji('üìã'),
        new ButtonBuilder()
          .setCustomId('music_stop')
          .setLabel('Parar')
          .setStyle(ButtonStyle.Danger)
          .setEmoji('‚èπÔ∏è'),
      );

      const response = await interaction.editReply({
        embeds: [embed],
        components: [buttonsRow],
      });

      // Handle button interactions
      const collector = response.createMessageComponentCollector({
        time: 300000, // 5 minutes
      });

      collector.on('collect', async i => {
        // Check if user is in the same voice channel
        const memberVoice = (i.member as any)?.voice?.channel;
        const botVoice = i.guild?.members?.me?.voice?.channel;

        if (!memberVoice || memberVoice.id !== botVoice?.id) {
          await i.reply({
            content: '‚ùå Voc√™ precisa estar no mesmo canal de voz que eu para usar os controles!',
            flags: MessageFlags.Ephemeral,
          });
          return;
        }

        switch (i.customId) {
          case 'music_pause':
            const paused = await musicService.pause(interaction.guildId!);
            await i.reply({
              content: paused ? '‚è∏Ô∏è M√∫sica pausada!' : '‚ñ∂Ô∏è M√∫sica retomada!',
              flags: MessageFlags.Ephemeral,
            });
            break;

          case 'music_skip':
            const skipped = await musicService.skip(interaction.guildId!);
            if (skipped) {
              await i.reply({ content: '‚è≠Ô∏è M√∫sica pulada!', flags: MessageFlags.Ephemeral });
            } else {
              await i.reply({ content: '‚ùå N√£o h√° pr√≥xima m√∫sica na fila!', flags: MessageFlags.Ephemeral });
            }
            break;

          case 'music_queue':
            const queueEmbed = await createQueueEmbed(interaction.guildId!, musicService);
            await i.reply({ embeds: [queueEmbed], flags: MessageFlags.Ephemeral });
            break;

          case 'music_stop':
            await musicService.stop(interaction.guildId!);
            await i.reply({ content: '‚èπÔ∏è M√∫sica parada e fila limpa!', flags: MessageFlags.Ephemeral });
            break;
        }
      });

      collector.on('end', () => {
        interaction.editReply({ components: [] }).catch(() => {});
      });

      // Log music activity
      logger.info(
        `üéµ Music command executed by ${interaction.user.tag} in ${interaction.guild?.name} - Query: ${query}, Track: ${addedTracks[0]?.title || 'Unknown'}`,
      );
    } catch (error) {
      logger.error('Play command error:', error);

      const errorEmbed = new EmbedBuilder()
        .setTitle('‚ùå Erro')
        .setDescription('Ocorreu um erro ao tentar tocar a m√∫sica.')
        .setColor('#FF0000');

      if (interaction.deferred) {
        await interaction.editReply({ embeds: [errorEmbed] });
      } else {
        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
      }
    }
  },
};

/**
 * Create queue embed
 */
async function createQueueEmbed(
  guildId: string,
  musicService: MusicService,
): Promise<EmbedBuilder> {
  const queue = await musicService.getQueue(guildId);

  const embed = new EmbedBuilder().setTitle('üìã Fila de M√∫sica').setColor('#0099FF').setTimestamp();

  if (!queue || queue.tracks.length === 0) {
    embed.setDescription('A fila est√° vazia.\n\nUse `/play` para adicionar m√∫sicas!');
    return embed;
  }

  const currentTrack = queue.currentTrack;
  if (currentTrack) {
    embed.addFields({
      name: 'üéµ Tocando Agora',
      value: `**${currentTrack.title}**\n${currentTrack.artist} ‚Ä¢ ${formatDuration(currentTrack.duration)}\nSolicitado por <@${currentTrack.requestedBy}>`,
      inline: false,
    });
  }

  if (queue.tracks.length > 0) {
    const upcomingTracks = queue.tracks
      .slice(0, 10)
      .map((track, index) => {
        return `**${index + 1}.** ${track.title}\n${track.artist} ‚Ä¢ ${formatDuration(track.duration)} ‚Ä¢ <@${track.requestedBy}>`;
      })
      .join('\n\n');

    embed.addFields({
      name: `üìã Pr√≥ximas (${queue.tracks.length})`,
      value:
        upcomingTracks +
        (queue.tracks.length > 10
          ? `\n\n... e mais ${queue.tracks.length - 10} m√∫sica${queue.tracks.length - 10 !== 1 ? 's' : ''}`
          : ''),
      inline: false,
    });

    const totalDuration = queue.tracks.reduce((total, track) => total + track.duration, 0);
    embed.addFields({
      name: 'üìä Informa√ß√µes',
      value: `‚è±Ô∏è Dura√ß√£o total: ${formatDuration(totalDuration)}\nüîÅ Loop: ${queue.loop === 'track' ? 'M√∫sica' : queue.loop === 'queue' ? 'Fila' : 'Desativado'}\nüîÄ Embaralhado: ${queue.shuffle ? 'Sim' : 'N√£o'}`,
      inline: false,
    });
  }

  return embed;
}

/**
 * Format duration from milliseconds to readable format
 */
function formatDuration(ms: number): string {
  if (!ms || ms <= 0) {
    return '0:00';
  }

  // Convert milliseconds to seconds
  const totalSeconds = Math.floor(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const hours = Math.floor(minutes / 60);
  const seconds = totalSeconds % 60;

  if (hours > 0) {
    return `${hours}:${(minutes % 60).toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  } else {
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  }
}

export default play;
