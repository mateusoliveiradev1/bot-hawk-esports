import {
  SlashCommandBuilder,
  EmbedBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  ComponentType,
  ChatInputCommandInteraction,
  ButtonInteraction,
} from 'discord.js';
import { Command } from '../../types/command';
import { ExtendedClient } from '../../types/client';
import { WeaponMasteryData, UserWeaponMastery } from '../../services/weapon-mastery.service';

export default {
  data: new SlashCommandBuilder()
    .setName('weapon-mastery')
    .setDescription('Visualizar maestria de armas PUBG')
    .addSubcommand(subcommand =>
      subcommand
        .setName('view')
        .setDescription('Ver sua maestria de armas')
        .addUserOption(option =>
          option
            .setName('user')
            .setDescription('Usu√°rio para visualizar (opcional)')
            .setRequired(false)
        )
    )
    .addSubcommand(subcommand =>
      subcommand.setName('sync').setDescription('Sincronizar maestria de armas com a API PUBG')
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('leaderboard')
        .setDescription('Ver ranking de maestria de armas')
        .addIntegerOption(option =>
          option
            .setName('limit')
            .setDescription('N√∫mero de jogadores no ranking (1-20)')
            .setMinValue(1)
            .setMaxValue(20)
            .setRequired(false)
        )
    )
    .addSubcommand(subcommand =>
      subcommand.setName('stats').setDescription('Ver estat√≠sticas gerais de maestria de armas')
    ),

  async execute(interaction: ChatInputCommandInteraction, client: ExtendedClient): Promise<void> {
    const subcommand = interaction.options.getSubcommand();

    try {
      switch (subcommand) {
        case 'view':
          await handleViewCommand(interaction, client);
          break;
        case 'sync':
          await handleSyncCommand(interaction, client);
          break;
        case 'leaderboard':
          await handleLeaderboardCommand(interaction, client);
          break;
        case 'stats':
          await handleStatsCommand(interaction, client);
          break;
        default:
          await interaction.reply({
            content: '‚ùå Subcomando n√£o reconhecido.',
            ephemeral: true,
          });
      }
    } catch (error) {
      console.error('Error in weapon-mastery command:', error);

      // Log detalhado para o canal de logs da API
      if (client.services?.pubg) {
        await client.services.pubg.logToChannel(
          '‚ùå Erro no Comando Weapon Mastery',
          `**Usu√°rio:** ${interaction.user.tag}\n**Subcomando:** ${subcommand}\n**Erro:** ${error instanceof Error ? error.message : 'Erro desconhecido'}`,
          'error'
        );
      }

      const errorEmbed = new EmbedBuilder()
        .setTitle('‚ùå Erro no comando')
        .setDescription('Ocorreu um erro ao executar o comando de maestria de armas.')
        .setColor('#FF0000')
        .addFields({
          name: 'üí° Dicas',
          value:
            '‚Ä¢ Verifique se sua conta PUBG est√° vinculada\n‚Ä¢ Tente novamente em alguns minutos\n‚Ä¢ Use `/register` se ainda n√£o se registrou',
          inline: false,
        })
        .setFooter({ text: 'Se o problema persistir, contate um administrador' });

      if (interaction.replied || interaction.deferred) {
        await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });
      } else {
        await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
      }
    }
  },
} as Command;

/**
 * Handle view subcommand
 */
async function handleViewCommand(
  interaction: ChatInputCommandInteraction,
  client: ExtendedClient
): Promise<void> {
  const targetUser = interaction.options.getUser('user') || interaction.user;
  const userId = targetUser.id;

  await interaction.deferReply();

  try {
    // Get user from database
    const user = await client.database.client.user.findUnique({
      where: { id: userId },
    });

    if (!user || !user.pubgUsername) {
      const embed = new EmbedBuilder()
        .setColor('#ff6b6b')
        .setTitle('‚ùå Usu√°rio n√£o encontrado')
        .setDescription(
          targetUser.id === interaction.user.id
            ? 'Voc√™ precisa vincular sua conta PUBG primeiro. Use `/pubg link` para vincular.'
            : 'Este usu√°rio n√£o possui uma conta PUBG vinculada.'
        )
        .setTimestamp();

      await interaction.editReply({ embeds: [embed] });
      return;
    }

    // Get weapon mastery data
    const masteryData = await (client as any).weaponMasteryService.getUserWeaponMastery(userId);

    if (!masteryData) {
      const embed = new EmbedBuilder()
        .setColor('#ffa500')
        .setTitle('‚ö†Ô∏è Dados n√£o encontrados')
        .setDescription(
          'Nenhum dado de maestria de armas encontrado. Use `/weapon-mastery sync` para sincronizar seus dados.'
        )
        .setTimestamp();

      await interaction.editReply({ embeds: [embed] });
      return;
    }

    // Create paginated weapon mastery display
    await displayWeaponMastery(interaction, masteryData, targetUser);
  } catch (error) {
    console.error('Error in view command:', error);

    const embed = new EmbedBuilder()
      .setColor('#ff6b6b')
      .setTitle('‚ùå Erro')
      .setDescription('N√£o foi poss√≠vel carregar os dados de maestria de armas.')
      .setTimestamp();

    await interaction.editReply({ embeds: [embed] });
  }
}

/**
 * Handle sync subcommand
 */
async function handleSyncCommand(
  interaction: ChatInputCommandInteraction,
  client: ExtendedClient
): Promise<void> {
  const userId = interaction.user.id;

  await interaction.deferReply();

  try {
    // Get user from database
    const user = await client.database.client.user.findUnique({
      where: { id: userId },
    });

    if (!user || !user.pubgUsername) {
      const embed = new EmbedBuilder()
        .setColor('#ff6b6b')
        .setTitle('‚ùå Conta n√£o vinculada')
        .setDescription(
          'Voc√™ precisa vincular sua conta PUBG primeiro. Use `/pubg link` para vincular.'
        )
        .setTimestamp();

      await interaction.editReply({ embeds: [embed] });
      return;
    }

    // Verificar se o servi√ßo de maestria de armas est√° dispon√≠vel
    if (!client.services?.weaponMastery) {
      throw new Error('Weapon mastery service not available');
    }

    // Force sync weapon mastery
    const synced = await client.services.weaponMastery.forceSyncUserWeaponMastery(
      userId,
      user.pubgUsername
    );

    if (synced) {
      const embed = new EmbedBuilder()
        .setColor('#4caf50')
        .setTitle('‚úÖ Sincroniza√ß√£o conclu√≠da')
        .setDescription(
          `Dados de maestria de armas sincronizados com sucesso para **${user.pubgUsername}**.\n\n` +
            'Use `/weapon-mastery view` para visualizar seus dados atualizados.'
        )
        .setTimestamp();

      await interaction.editReply({ embeds: [embed] });
    } else {
      const embed = new EmbedBuilder()
        .setColor('#ffa500')
        .setTitle('‚ö†Ô∏è Sincroniza√ß√£o falhou')
        .setDescription(
          'N√£o foi poss√≠vel sincronizar os dados de maestria de armas. Poss√≠veis causas:\n\n' +
            '‚Ä¢ Jogador n√£o encontrado na API PUBG\n' +
            '‚Ä¢ Dados de maestria n√£o dispon√≠veis\n' +
            '‚Ä¢ Erro tempor√°rio da API\n\n' +
            'Tente novamente em alguns minutos.'
        )
        .setTimestamp();

      await interaction.editReply({ embeds: [embed] });
    }
  } catch (error) {
    console.error('Error in sync command:', error);

    const embed = new EmbedBuilder()
      .setColor('#ff6b6b')
      .setTitle('‚ùå Erro na sincroniza√ß√£o')
      .setDescription('Ocorreu um erro durante a sincroniza√ß√£o. Tente novamente mais tarde.')
      .setTimestamp();

    await interaction.editReply({ embeds: [embed] });
  }
}

/**
 * Handle leaderboard subcommand
 */
async function handleLeaderboardCommand(
  interaction: ChatInputCommandInteraction,
  client: ExtendedClient
): Promise<void> {
  const limit = interaction.options.getInteger('limit') || 10;

  await interaction.deferReply();

  try {
    // Verificar se o servi√ßo de maestria de armas est√° dispon√≠vel
    if (!client.services?.weaponMastery) {
      throw new Error('Weapon mastery service not available');
    }

    const leaderboard = await client.services.weaponMastery.getWeaponMasteryLeaderboard(limit);

    if (leaderboard.length === 0) {
      const embed = new EmbedBuilder()
        .setColor('#ffa500')
        .setTitle('üìä Ranking de Maestria de Armas')
        .setDescription('Nenhum dado de maestria encontrado ainda.')
        .setTimestamp();

      await interaction.editReply({ embeds: [embed] });
      return;
    }

    const embed = new EmbedBuilder()
      .setColor('#4caf50')
      .setTitle('üèÜ Ranking de Maestria de Armas')
      .setDescription('Top jogadores por n√≠vel total de maestria')
      .setTimestamp();

    let description = '';
    const medals = ['ü•á', 'ü•à', 'ü•â'];

    for (let i = 0; i < leaderboard.length; i++) {
      const player = leaderboard[i];
      const medal = medals[i] || `**${i + 1}.**`;

      description += `${medal} **${player?.pubgName || 'N/A'}**\n`;
      description += `‚îú N√≠vel Total: **${player?.totalLevel || 0}**\n`;
      description += `‚îú XP Total: **${player?.totalXP?.toLocaleString() || '0'}**\n`;
      description += `‚îú Armas: **${player?.weaponCount || 0}**\n`;
      description += `‚îî Favorita: **${player?.favoriteWeapon || 'N/A'}**\n\n`;
    }

    embed.setDescription(description);

    await interaction.editReply({ embeds: [embed] });
  } catch (error) {
    console.error('Error in leaderboard command:', error);

    const embed = new EmbedBuilder()
      .setColor('#ff6b6b')
      .setTitle('‚ùå Erro')
      .setDescription('N√£o foi poss√≠vel carregar o ranking de maestria de armas.')
      .setTimestamp();

    await interaction.editReply({ embeds: [embed] });
  }
}

/**
 * Handle stats subcommand
 */
async function handleStatsCommand(
  interaction: ChatInputCommandInteraction,
  client: ExtendedClient
): Promise<void> {
  await interaction.deferReply();

  try {
    const stats = await (client as any).weaponMasteryService.getWeaponMasteryStats();

    const embed = new EmbedBuilder()
      .setColor('#2196f3')
      .setTitle('üìä Estat√≠sticas de Maestria de Armas')
      .addFields(
        {
          name: 'üë• Usu√°rios',
          value: `**${stats.totalUsers}** jogadores\n**${stats.totalWeapons}** armas registradas`,
          inline: true,
        },
        {
          name: 'üìà M√©dias',
          value: `**${stats.averageLevel.toFixed(1)}** n√≠vel m√©dio por jogador`,
          inline: true,
        },
        {
          name: 'üî´ Armas Populares',
          value:
            stats.topWeapons
              .slice(0, 5)
              .map(
                (weapon: any, index: number) =>
                  `**${index + 1}.** ${weapon.name} (${weapon.users} usu√°rios)`
              )
              .join('\n') || 'Nenhuma arma registrada',
          inline: false,
        }
      )
      .setTimestamp();

    await interaction.editReply({ embeds: [embed] });
  } catch (error) {
    console.error('Error in stats command:', error);

    const embed = new EmbedBuilder()
      .setColor('#ff6b6b')
      .setTitle('‚ùå Erro')
      .setDescription('N√£o foi poss√≠vel carregar as estat√≠sticas de maestria de armas.')
      .setTimestamp();

    await interaction.editReply({ embeds: [embed] });
  }
}

/**
 * Display weapon mastery with pagination
 */
async function displayWeaponMastery(
  interaction: ChatInputCommandInteraction,
  masteryData: UserWeaponMastery,
  targetUser: any
): Promise<void> {
  const weaponsPerPage = 5;
  const totalPages = Math.ceil(masteryData.weapons.length / weaponsPerPage);
  let currentPage = 0;

  const generateEmbed = (page: number): EmbedBuilder => {
    const start = page * weaponsPerPage;
    const end = start + weaponsPerPage;
    const weaponsOnPage = masteryData.weapons.slice(start, end);

    const embed = new EmbedBuilder()
      .setColor('#4caf50')
      .setTitle(`üî´ Maestria de Armas - ${masteryData.pubgName}`)
      .setThumbnail(targetUser.displayAvatarURL({ dynamic: true }))
      .addFields({
        name: 'üìä Resumo Geral',
        value:
          `**N√≠vel Total:** ${masteryData.totalLevel}\n` +
          `**XP Total:** ${masteryData.totalXP.toLocaleString()}\n` +
          `**Armas Dominadas:** ${masteryData.weapons.length}\n` +
          `**Arma Favorita:** ${masteryData.favoriteWeapon}`,
        inline: false,
      })
      .setFooter({
        text: `P√°gina ${page + 1} de ${totalPages} ‚Ä¢ √öltima sincroniza√ß√£o: ${masteryData.lastSyncAt.toLocaleDateString('pt-BR')}`,
      })
      .setTimestamp();

    // Add weapons on current page
    for (const weapon of weaponsOnPage) {
      const progressBar = createProgressBar(weapon.level, 100);
      const medalCount = weapon.medals.length;

      embed.addFields({
        name: `${getWeaponEmoji(weapon.weaponName)} ${weapon.weaponName}`,
        value:
          `**N√≠vel:** ${weapon.level} ${progressBar}\n` +
          `**XP:** ${weapon.xp.toLocaleString()}\n` +
          `**Tier:** ${weapon.tier}\n` +
          `**Medalhas:** ${medalCount} üèÖ`,
        inline: true,
      });
    }

    return embed;
  };

  const generateButtons = (page: number): ActionRowBuilder<ButtonBuilder> => {
    return new ActionRowBuilder<ButtonBuilder>().addComponents(
      new ButtonBuilder()
        .setCustomId('weapon_mastery_prev')
        .setLabel('‚óÄÔ∏è Anterior')
        .setStyle(ButtonStyle.Secondary)
        .setDisabled(page === 0),
      new ButtonBuilder()
        .setCustomId('weapon_mastery_next')
        .setLabel('Pr√≥xima ‚ñ∂Ô∏è')
        .setStyle(ButtonStyle.Secondary)
        .setDisabled(page === totalPages - 1),
      new ButtonBuilder()
        .setCustomId('weapon_mastery_sync')
        .setLabel('üîÑ Sincronizar')
        .setStyle(ButtonStyle.Primary)
        .setDisabled(targetUser.id !== interaction.user.id)
    );
  };

  const embed = generateEmbed(currentPage);
  const buttons = generateButtons(currentPage);

  const message = await interaction.editReply({
    embeds: [embed],
    components: totalPages > 1 ? [buttons] : [],
  });

  if (totalPages <= 1) {
    return;
  }

  // Handle button interactions
  const collector = message.createMessageComponentCollector({
    componentType: ComponentType.Button,
    time: 300000, // 5 minutes
  });

  collector.on('collect', async (buttonInteraction: ButtonInteraction) => {
    if (buttonInteraction.user.id !== interaction.user.id) {
      await buttonInteraction.reply({
        content: '‚ùå Apenas quem executou o comando pode usar estes bot√µes.',
        ephemeral: true,
      });
      return;
    }

    await buttonInteraction.deferUpdate();

    switch (buttonInteraction.customId) {
      case 'weapon_mastery_prev':
        currentPage = Math.max(0, currentPage - 1);
        break;
      case 'weapon_mastery_next':
        currentPage = Math.min(totalPages - 1, currentPage + 1);
        break;
      case 'weapon_mastery_sync':
        // Handle sync button
        await handleSyncFromButton(buttonInteraction, interaction.client as ExtendedClient);
        return;
    }

    const newEmbed = generateEmbed(currentPage);
    const newButtons = generateButtons(currentPage);

    await buttonInteraction.editReply({
      embeds: [newEmbed],
      components: [newButtons],
    });
  });

  collector.on('end', async () => {
    try {
      const disabledButtons = new ActionRowBuilder<ButtonBuilder>().addComponents(
        ...buttons.components.map(button => ButtonBuilder.from(button).setDisabled(true))
      );

      await interaction.editReply({
        components: [disabledButtons],
      });
    } catch (error) {
      // Ignore errors when disabling buttons (message might be deleted)
    }
  });
}

/**
 * Handle sync from button interaction
 */
async function handleSyncFromButton(
  buttonInteraction: ButtonInteraction,
  client: ExtendedClient
): Promise<void> {
  const userId = buttonInteraction.user.id;

  try {
    // Get user from database
    const user = await client.database.client.user.findUnique({
      where: { id: userId },
    });

    if (!user || !user.pubgUsername) {
      await buttonInteraction.followUp({
        content: '‚ùå Voc√™ precisa vincular sua conta PUBG primeiro.',
        ephemeral: true,
      });
      return;
    }

    await buttonInteraction.followUp({
      content: 'üîÑ Sincronizando dados de maestria de armas...',
      ephemeral: true,
    });

    // Force sync weapon mastery
    const synced = await (client as any).weaponMasteryService.forceSyncUserWeaponMastery(
      userId,
      user.pubgUsername
    );

    if (synced) {
      await buttonInteraction.followUp({
        content:
          '‚úÖ Dados sincronizados com sucesso! Use o comando novamente para ver as atualiza√ß√µes.',
        ephemeral: true,
      });
    } else {
      await buttonInteraction.followUp({
        content: '‚ùå Falha na sincroniza√ß√£o. Tente novamente mais tarde.',
        ephemeral: true,
      });
    }
  } catch (error) {
    console.error('Error in sync from button:', error);

    await buttonInteraction.followUp({
      content: '‚ùå Erro durante a sincroniza√ß√£o.',
      ephemeral: true,
    });
  }
}

/**
 * Create a progress bar for weapon level
 */
function createProgressBar(current: number, max: number, length: number = 10): string {
  const percentage = Math.min(current / max, 1);
  const filled = Math.round(length * percentage);
  const empty = length - filled;

  return `[${'‚ñà'.repeat(filled)}${'‚ñë'.repeat(empty)}] ${current}/${max}`;
}

/**
 * Get emoji for weapon type
 */
function getWeaponEmoji(weaponName: string): string {
  const weaponEmojis: Record<string, string> = {
    AKM: 'üî´',
    M416: 'üî´',
    'SCAR-L': 'üî´',
    M16A4: 'üî´',
    Kar98k: 'üéØ',
    M24: 'üéØ',
    AWM: 'üéØ',
    VSS: 'üéØ',
    UMP45: 'üî´',
    Vector: 'üî´',
    'Tommy Gun': 'üî´',
    S12K: 'üí•',
    S1897: 'üí•',
    S686: 'üí•',
    DBS: 'üí•',
    P92: 'üî´',
    P1911: 'üî´',
    P18C: 'üî´',
    R1895: 'üî´',
    Crossbow: 'üèπ',
    Pan: 'üç≥',
    Machete: 'üî™',
    Sickle: 'üî™',
    Crowbar: 'üîß',
  };

  return weaponEmojis[weaponName] || 'üî´';
}
