import {
  SlashCommandBuilder,
  EmbedBuilder,
  ChatInputCommandInteraction,
  CommandInteraction,
  PermissionFlagsBits,
  User,
} from 'discord.js';
import { Command, CommandCategory } from '@/types/command';
import { ExtendedClient } from '@/types/client';
import { Logger } from '@/utils/logger';
import { PUNISHMENT_CONFIG } from '../../config/punishment.config';

/**
 * Punishment management command - View and manage user punishments
 */
const punishment: Command = {
  data: new SlashCommandBuilder()
    .setName('punishment')
    .setDescription('üî® Gerenciar sistema de puni√ß√µes')
    .addSubcommand(subcommand =>
      subcommand
        .setName('history')
        .setDescription('Ver hist√≥rico de puni√ß√µes de um usu√°rio')
        .addUserOption(option =>
          option.setName('usuario').setDescription('Usu√°rio para ver o hist√≥rico').setRequired(true),
        ),
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('warnings')
        .setDescription('Ver avisos ativos de um usu√°rio')
        .addUserOption(option =>
          option.setName('usuario').setDescription('Usu√°rio para ver os avisos').setRequired(true),
        ),
    )
    .addSubcommand(subcommand =>
      subcommand.setName('config').setDescription('Ver configura√ß√µes do sistema de puni√ß√µes'),
    )
    .addSubcommand(subcommand =>
      subcommand.setName('stats').setDescription('Ver estat√≠sticas gerais de puni√ß√µes do servidor'),
    )
    .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild) as SlashCommandBuilder,

  category: CommandCategory.ADMIN,
  cooldown: 5,

  async execute(
    interaction: CommandInteraction | ChatInputCommandInteraction,
    client: ExtendedClient,
  ): Promise<void> {
    const logger = new Logger();
    const punishmentService = client.services?.punishment;

    if (!punishmentService) {
      const errorEmbed = new EmbedBuilder()
        .setTitle('‚ùå Servi√ßo Indispon√≠vel')
        .setDescription('O servi√ßo de puni√ß√µes n√£o est√° dispon√≠vel no momento.')
        .setColor(0xff0000);

      await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
      return;
    }

    try {
      await interaction.deferReply();

      const subcommand = (interaction as ChatInputCommandInteraction).options.getSubcommand();
      const guildId = interaction.guild!.id;

      switch (subcommand) {
        case 'history':
          await handleHistoryCommand(interaction as ChatInputCommandInteraction, punishmentService);
          break;

        case 'warnings':
          await handleWarningsCommand(
            interaction as ChatInputCommandInteraction,
            punishmentService,
          );
          break;

        case 'config':
          await handleConfigCommand(interaction as ChatInputCommandInteraction);
          break;

        case 'stats':
          await handleStatsCommand(
            interaction as ChatInputCommandInteraction,
            punishmentService,
            guildId,
          );
          break;

        default:
          const errorEmbed = new EmbedBuilder()
            .setTitle('‚ùå Subcomando Inv√°lido')
            .setDescription('Subcomando n√£o reconhecido.')
            .setColor(0xff0000);

          await interaction.editReply({ embeds: [errorEmbed] });
      }
    } catch (error) {
      logger.error('Error in punishment command:', error);

      const errorEmbed = new EmbedBuilder()
        .setTitle('‚ùå Erro')
        .setDescription('Ocorreu um erro ao executar o comando.')
        .setColor(0xff0000);

      await interaction.editReply({ embeds: [errorEmbed] });
    }
  },
};

/**
 * Handle punishment history subcommand
 */
async function handleHistoryCommand(
  interaction: ChatInputCommandInteraction,
  punishmentService: any,
): Promise<void> {
  const targetUser = interaction.options.getUser('usuario', true);
  const punishments = punishmentService.getUserPunishments(targetUser.id);

  const embed = new EmbedBuilder()
    .setTitle(`üìã Hist√≥rico de Puni√ß√µes - ${targetUser.username}`)
    .setThumbnail(targetUser.displayAvatarURL())
    .setColor(0xff9500)
    .setTimestamp();

  if (punishments.length === 0) {
    embed.setDescription('‚úÖ Este usu√°rio n√£o possui puni√ß√µes registradas.');
  } else {
    const recentPunishments = punishments.slice(0, 10); // Show last 10 punishments

    let description = `**Total de Puni√ß√µes:** ${punishments.length}\n\n`;

    recentPunishments.forEach((punishment: any, index: number) => {
      const date = new Date(punishment.timestamp).toLocaleDateString('pt-BR');
      const typeEmoji = getTypeEmoji(punishment.type);

      description += `${typeEmoji} **${punishment.type.replace('_', ' ').toUpperCase()}**\n`;
      description += `üìÖ ${date} | üí∞ -${punishment.penalty.coins} moedas | ‚≠ê -${punishment.penalty.xp} XP\n`;
      description += `üìù ${punishment.reason}\n\n`;
    });

    if (punishments.length > 10) {
      description += `*... e mais ${punishments.length - 10} puni√ß√µes antigas*`;
    }

    embed.setDescription(description);
  }

  await interaction.editReply({ embeds: [embed] });
}

/**
 * Handle warnings subcommand
 */
async function handleWarningsCommand(
  interaction: ChatInputCommandInteraction,
  punishmentService: any,
): Promise<void> {
  const targetUser = interaction.options.getUser('usuario', true);
  const guildId = interaction.guild!.id;
  const warnings = await punishmentService.getUserWarnings(targetUser.id, guildId);

  const embed = new EmbedBuilder()
    .setTitle(`‚ö†Ô∏è Avisos Ativos - ${targetUser.username}`)
    .setThumbnail(targetUser.displayAvatarURL())
    .setColor(0xffa500)
    .setTimestamp();

  if (warnings.length === 0) {
    embed.setDescription('‚úÖ Este usu√°rio n√£o possui avisos ativos.');
  } else {
    let description = `**Avisos Ativos:** ${warnings.length}/${PUNISHMENT_CONFIG.warnings.maxWarnings}\n\n`;

    warnings.forEach((warning: any, index: number) => {
      const issueDate = new Date(warning.issuedAt).toLocaleDateString('pt-BR');
      const expiryDate = new Date(warning.expiresAt).toLocaleDateString('pt-BR');
      const typeEmoji = getTypeEmoji(warning.type);

      description += `${typeEmoji} **Aviso ${index + 1}**\n`;
      description += `üìÖ Emitido: ${issueDate} | Expira: ${expiryDate}\n`;
      description += `üìù ${warning.reason}\n\n`;
    });

    // Warning about escalation
    if (warnings.length >= PUNISHMENT_CONFIG.warnings.maxWarnings - 1) {
      description += 'üö® **ATEN√á√ÉO:** Pr√≥ximo aviso resultar√° em penalidade escalada!';
    }

    embed.setDescription(description);
  }

  await interaction.editReply({ embeds: [embed] });
}

/**
 * Handle config subcommand
 */
async function handleConfigCommand(interaction: ChatInputCommandInteraction): Promise<void> {
  const embed = new EmbedBuilder()
    .setTitle('‚öôÔ∏è Configura√ß√µes do Sistema de Puni√ß√µes')
    .setColor(0x0099ff)
    .setTimestamp();

  let description = `**Status:** ${PUNISHMENT_CONFIG.enabled ? '‚úÖ Ativo' : '‚ùå Desativado'}\n\n`;

  description += '**üìã Penalidades:**\n';
  description += `‚Ä¢ **N√£o Check-out:** -${PUNISHMENT_CONFIG.penalties.no_checkout.xpPenalty} XP, -${PUNISHMENT_CONFIG.penalties.no_checkout.coinsPenalty} moedas\n`;
  description += `‚Ä¢ **N√£o Compareceu:** -${PUNISHMENT_CONFIG.penalties.no_show_up.xpPenalty} XP, -${PUNISHMENT_CONFIG.penalties.no_show_up.coinsPenalty} moedas\n`;
  description += `‚Ä¢ **Sa√≠da Precoce:** -${PUNISHMENT_CONFIG.penalties.early_leave.xpPenalty} XP, -${PUNISHMENT_CONFIG.penalties.early_leave.coinsPenalty} moedas\n\n`;

  description += '**‚ö†Ô∏è Sistema de Avisos:**\n';
  description += `‚Ä¢ **M√°ximo de Avisos:** ${PUNISHMENT_CONFIG.warnings.maxWarnings}\n`;
  description += `‚Ä¢ **Dura√ß√£o do Aviso:** ${PUNISHMENT_CONFIG.warnings.warningDuration} horas\n`;
  description += `‚Ä¢ **Penalidade Escalada:** -${PUNISHMENT_CONFIG.warnings.escalationPenalty.xpPenalty} XP, -${PUNISHMENT_CONFIG.warnings.escalationPenalty.coinsPenalty} moedas\n\n`;

  description += '**‚è∞ Tempos Limite:**\n';
  description += `‚Ä¢ **Sem Check-out:** ${PUNISHMENT_CONFIG.timeouts.noCheckoutTimeout} horas\n`;
  description += `‚Ä¢ **N√£o Compareceu:** ${PUNISHMENT_CONFIG.timeouts.noShowUpTimeout} hora(s)\n`;
  description += `‚Ä¢ **Sa√≠da Precoce:** ${PUNISHMENT_CONFIG.timeouts.earlyLeaveTimeout} hora(s)\n`;

  embed.setDescription(description);

  await interaction.editReply({ embeds: [embed] });
}

/**
 * Handle stats subcommand
 */
async function handleStatsCommand(
  interaction: ChatInputCommandInteraction,
  punishmentService: any,
  guildId: string,
): Promise<void> {
  // This would require additional methods in PunishmentService to get guild stats
  const embed = new EmbedBuilder()
    .setTitle('üìä Estat√≠sticas de Puni√ß√µes do Servidor')
    .setColor(0x9932cc)
    .setTimestamp();

  // For now, show a placeholder message
  embed.setDescription(
    'üìà **Estat√≠sticas em Desenvolvimento**\n\n' +
      'As estat√≠sticas detalhadas de puni√ß√µes estar√£o dispon√≠veis em breve. ' +
      'Isso incluir√°:\n\n' +
      '‚Ä¢ Total de puni√ß√µes por tipo\n' +
      '‚Ä¢ Usu√°rios mais punidos\n' +
      '‚Ä¢ Tend√™ncias mensais\n' +
      '‚Ä¢ Taxa de reincid√™ncia\n' +
      '‚Ä¢ Efetividade do sistema de avisos',
  );

  await interaction.editReply({ embeds: [embed] });
}

/**
 * Get emoji for punishment type
 */
function getTypeEmoji(type: string): string {
  const typeEmojis: Record<string, string> = {
    no_checkout: 'üö™',
    no_show_up: 'üëª',
    early_leave: 'üèÉ',
    warning_escalation: 'üö®',
  };

  return typeEmojis[type] || '‚ùì';
}

export default punishment;
