import {
  SlashCommandBuilder,
  ChatInputCommandInteraction,
  EmbedBuilder,
  PermissionFlagsBits
} from 'discord.js';
import { Command } from '../../types/command';
import { ExtendedClient } from '../../types/client';
import { Logger } from '../../utils/logger';

const logger = new Logger();

export default {
  category: 'admin',
  data: new SlashCommandBuilder()
    .setName('ticket-config')
    .setDescription('Configurar sistema de tickets')
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator)
    .addSubcommand(subcommand =>
      subcommand
        .setName('timeout')
        .setDescription('Configurar tempo de inatividade para fechamento autom√°tico')
        .addIntegerOption(option =>
          option
            .setName('horas')
            .setDescription('Horas de inatividade antes do fechamento autom√°tico (0 = desabilitar)')
            .setRequired(true)
            .setMinValue(0)
            .setMaxValue(168) // 7 dias m√°ximo
        )
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('max-tickets')
        .setDescription('Configurar n√∫mero m√°ximo de tickets por usu√°rio')
        .addIntegerOption(option =>
          option
            .setName('quantidade')
            .setDescription('N√∫mero m√°ximo de tickets por usu√°rio')
            .setRequired(true)
            .setMinValue(1)
            .setMaxValue(10)
        )
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('auto-assign')
        .setDescription('Configurar atribui√ß√£o autom√°tica de tickets')
        .addBooleanOption(option =>
          option
            .setName('ativo')
            .setDescription('Ativar ou desativar atribui√ß√£o autom√°tica')
            .setRequired(true)
        )
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('require-reason')
        .setDescription('Configurar se motivo √© obrigat√≥rio para criar tickets')
        .addBooleanOption(option =>
          option
            .setName('obrigatorio')
            .setDescription('Tornar motivo obrigat√≥rio ou opcional')
            .setRequired(true)
        )
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('notifications')
        .setDescription('Configurar notifica√ß√µes do sistema de tickets')
        .addBooleanOption(option =>
          option
            .setName('criar')
            .setDescription('Notificar quando ticket for criado')
            .setRequired(false)
        )
        .addBooleanOption(option =>
          option
            .setName('atribuir')
            .setDescription('Notificar quando ticket for atribu√≠do')
            .setRequired(false)
        )
        .addBooleanOption(option =>
          option
            .setName('fechar')
            .setDescription('Notificar quando ticket for fechado')
            .setRequired(false)
        )
        .addBooleanOption(option =>
          option
            .setName('reabrir')
            .setDescription('Notificar quando ticket for reaberto')
            .setRequired(false)
        )
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('view')
        .setDescription('Ver configura√ß√µes atuais do sistema de tickets')
    ),

  async execute(interaction: ChatInputCommandInteraction, client: ExtendedClient) {
    try {
      const subcommand = interaction.options.getSubcommand();
      const ticketService = client.services?.ticket;

      if (!ticketService) {
        const errorEmbed = new EmbedBuilder()
          .setTitle('‚ùå Erro')
          .setDescription('Servi√ßo de tickets n√£o est√° dispon√≠vel.')
          .setColor('#FF0000');
        
        await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
        return;
      }

      switch (subcommand) {
        case 'timeout':
          await handleTimeoutConfig(interaction, ticketService);
          break;
        case 'max-tickets':
          await handleMaxTicketsConfig(interaction, ticketService);
          break;
        case 'auto-assign':
          await handleAutoAssignConfig(interaction, ticketService);
          break;
        case 'require-reason':
          await handleRequireReasonConfig(interaction, ticketService);
          break;
        case 'notifications':
          await handleNotificationsConfig(interaction, ticketService);
          break;
        case 'view':
          await handleViewConfig(interaction, ticketService);
          break;
        default:
          await interaction.reply({ content: 'Subcomando n√£o reconhecido.', ephemeral: true });
      }
    } catch (error) {
      logger.error('Error in ticket-config command:', error);
      
      const errorEmbed = new EmbedBuilder()
        .setTitle('‚ùå Erro')
        .setDescription('Ocorreu um erro ao processar o comando.')
        .setColor('#FF0000');
      
      if (interaction.replied || interaction.deferred) {
        await interaction.editReply({ embeds: [errorEmbed] });
      } else {
        await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
      }
    }
  },
} as Command;

/**
 * Handle timeout configuration
 */
async function handleTimeoutConfig(interaction: ChatInputCommandInteraction, ticketService: any) {
  const horas = interaction.options.getInteger('horas', true);
  const guildId = interaction.guildId!;

  await interaction.deferReply({ ephemeral: true });

  try {
    const currentSettings = ticketService.getTicketSettings(guildId);
    const newSettings = {
      ...currentSettings,
      closeAfterInactivity: horas
    };

    await ticketService.updateTicketSettings(guildId, newSettings);

    const embed = new EmbedBuilder()
      .setTitle('‚úÖ Configura√ß√£o Atualizada')
      .setDescription(
        horas === 0 
          ? 'Fechamento autom√°tico por inatividade foi **desabilitado**.'
          : `Tickets ser√£o fechados automaticamente ap√≥s **${horas} horas** de inatividade.`
      )
      .setColor('#00FF00')
      .addFields(
        { name: '‚è∞ Tempo Anterior', value: `${currentSettings.closeAfterInactivity}h`, inline: true },
        { name: 'üÜï Novo Tempo', value: horas === 0 ? 'Desabilitado' : `${horas}h`, inline: true }
      )
      .setTimestamp();

    await interaction.editReply({ embeds: [embed] });
  } catch (error) {
    logger.error('Error updating timeout config:', error);
    
    const errorEmbed = new EmbedBuilder()
      .setTitle('‚ùå Erro')
      .setDescription('N√£o foi poss√≠vel atualizar a configura√ß√£o de timeout.')
      .setColor('#FF0000');
    
    await interaction.editReply({ embeds: [errorEmbed] });
  }
}

/**
 * Handle max tickets configuration
 */
async function handleMaxTicketsConfig(interaction: ChatInputCommandInteraction, ticketService: any) {
  const quantidade = interaction.options.getInteger('quantidade', true);
  const guildId = interaction.guildId!;

  await interaction.deferReply({ ephemeral: true });

  try {
    const currentSettings = ticketService.getTicketSettings(guildId);
    const newSettings = {
      ...currentSettings,
      maxTicketsPerUser: quantidade
    };

    await ticketService.updateTicketSettings(guildId, newSettings);

    const embed = new EmbedBuilder()
      .setTitle('‚úÖ Configura√ß√£o Atualizada')
      .setDescription(`N√∫mero m√°ximo de tickets por usu√°rio definido para **${quantidade}**.`)
      .setColor('#00FF00')
      .addFields(
        { name: 'üìä Limite Anterior', value: `${currentSettings.maxTicketsPerUser}`, inline: true },
        { name: 'üÜï Novo Limite', value: `${quantidade}`, inline: true }
      )
      .setTimestamp();

    await interaction.editReply({ embeds: [embed] });
  } catch (error) {
    logger.error('Error updating max tickets config:', error);
    
    const errorEmbed = new EmbedBuilder()
      .setTitle('‚ùå Erro')
      .setDescription('N√£o foi poss√≠vel atualizar a configura√ß√£o de limite de tickets.')
      .setColor('#FF0000');
    
    await interaction.editReply({ embeds: [errorEmbed] });
  }
}

/**
 * Handle auto assign configuration
 */
async function handleAutoAssignConfig(interaction: ChatInputCommandInteraction, ticketService: any) {
  const ativo = interaction.options.getBoolean('ativo', true);
  const guildId = interaction.guildId!;

  await interaction.deferReply({ ephemeral: true });

  try {
    const currentSettings = ticketService.getTicketSettings(guildId);
    const newSettings = {
      ...currentSettings,
      autoAssign: ativo
    };

    await ticketService.updateTicketSettings(guildId, newSettings);

    const embed = new EmbedBuilder()
      .setTitle('‚úÖ Configura√ß√£o Atualizada')
      .setDescription(
        ativo 
          ? 'Atribui√ß√£o autom√°tica de tickets foi **ativada**.'
          : 'Atribui√ß√£o autom√°tica de tickets foi **desativada**.'
      )
      .setColor('#00FF00')
      .addFields(
        { name: 'üîÑ Status Anterior', value: currentSettings.autoAssign ? 'Ativo' : 'Inativo', inline: true },
        { name: 'üÜï Novo Status', value: ativo ? 'Ativo' : 'Inativo', inline: true }
      )
      .setTimestamp();

    await interaction.editReply({ embeds: [embed] });
  } catch (error) {
    logger.error('Error updating auto assign config:', error);
    
    const errorEmbed = new EmbedBuilder()
      .setTitle('‚ùå Erro')
      .setDescription('N√£o foi poss√≠vel atualizar a configura√ß√£o de atribui√ß√£o autom√°tica.')
      .setColor('#FF0000');
    
    await interaction.editReply({ embeds: [errorEmbed] });
  }
}

/**
 * Handle require reason configuration
 */
async function handleRequireReasonConfig(interaction: ChatInputCommandInteraction, ticketService: any) {
  const obrigatorio = interaction.options.getBoolean('obrigatorio', true);
  const guildId = interaction.guildId!;

  await interaction.deferReply({ ephemeral: true });

  try {
    const currentSettings = ticketService.getTicketSettings(guildId);
    const newSettings = {
      ...currentSettings,
      requireReason: obrigatorio
    };

    await ticketService.updateTicketSettings(guildId, newSettings);

    const embed = new EmbedBuilder()
      .setTitle('‚úÖ Configura√ß√£o Atualizada')
      .setDescription(
        obrigatorio 
          ? 'Motivo agora √© **obrigat√≥rio** para criar tickets.'
          : 'Motivo agora √© **opcional** para criar tickets.'
      )
      .setColor('#00FF00')
      .addFields(
        { name: 'üìù Status Anterior', value: currentSettings.requireReason ? 'Obrigat√≥rio' : 'Opcional', inline: true },
        { name: 'üÜï Novo Status', value: obrigatorio ? 'Obrigat√≥rio' : 'Opcional', inline: true }
      )
      .setTimestamp();

    await interaction.editReply({ embeds: [embed] });
  } catch (error) {
    logger.error('Error updating require reason config:', error);
    
    const errorEmbed = new EmbedBuilder()
      .setTitle('‚ùå Erro')
      .setDescription('N√£o foi poss√≠vel atualizar a configura√ß√£o de motivo obrigat√≥rio.')
      .setColor('#FF0000');
    
    await interaction.editReply({ embeds: [errorEmbed] });
  }
}

/**
 * Handle notifications configuration
 */
async function handleNotificationsConfig(interaction: ChatInputCommandInteraction, ticketService: any) {
  const criar = interaction.options.getBoolean('criar');
  const atribuir = interaction.options.getBoolean('atribuir');
  const fechar = interaction.options.getBoolean('fechar');
  const reabrir = interaction.options.getBoolean('reabrir');
  const guildId = interaction.guildId!;

  await interaction.deferReply({ ephemeral: true });

  try {
    const currentSettings = ticketService.getTicketSettings(guildId);
    const newNotificationSettings = {
      onCreate: criar !== null ? criar : currentSettings.notificationSettings.onCreate,
      onAssign: atribuir !== null ? atribuir : currentSettings.notificationSettings.onAssign,
      onClose: fechar !== null ? fechar : currentSettings.notificationSettings.onClose,
      onReopen: reabrir !== null ? reabrir : currentSettings.notificationSettings.onReopen
    };

    const newSettings = {
      ...currentSettings,
      notificationSettings: newNotificationSettings
    };

    await ticketService.updateTicketSettings(guildId, newSettings);

    const embed = new EmbedBuilder()
      .setTitle('‚úÖ Notifica√ß√µes Atualizadas')
      .setDescription('Configura√ß√µes de notifica√ß√£o foram atualizadas com sucesso.')
      .setColor('#00FF00')
      .addFields(
        { name: 'üé´ Criar Ticket', value: newNotificationSettings.onCreate ? '‚úÖ Ativo' : '‚ùå Inativo', inline: true },
        { name: 'üéØ Atribuir Ticket', value: newNotificationSettings.onAssign ? '‚úÖ Ativo' : '‚ùå Inativo', inline: true },
        { name: 'üîí Fechar Ticket', value: newNotificationSettings.onClose ? '‚úÖ Ativo' : '‚ùå Inativo', inline: true },
        { name: 'üîì Reabrir Ticket', value: newNotificationSettings.onReopen ? '‚úÖ Ativo' : '‚ùå Inativo', inline: true }
      )
      .setTimestamp();

    await interaction.editReply({ embeds: [embed] });
  } catch (error) {
    logger.error('Error updating notifications config:', error);
    
    const errorEmbed = new EmbedBuilder()
      .setTitle('‚ùå Erro')
      .setDescription('N√£o foi poss√≠vel atualizar as configura√ß√µes de notifica√ß√£o.')
      .setColor('#FF0000');
    
    await interaction.editReply({ embeds: [errorEmbed] });
  }
}

/**
 * Handle view configuration
 */
async function handleViewConfig(interaction: ChatInputCommandInteraction, ticketService: any) {
  const guildId = interaction.guildId!;

  await interaction.deferReply({ ephemeral: true });

  try {
    const settings = ticketService.getTicketSettings(guildId);

    const embed = new EmbedBuilder()
      .setTitle('‚öôÔ∏è Configura√ß√µes do Sistema de Tickets')
      .setDescription('Configura√ß√µes atuais do sistema de tickets para este servidor.')
      .setColor('#0099FF')
      .addFields(
        { name: 'üîß Sistema', value: settings.enabled ? '‚úÖ Ativo' : '‚ùå Inativo', inline: true },
        { name: 'üìä Max Tickets/Usu√°rio', value: `${settings.maxTicketsPerUser}`, inline: true },
        { name: 'üîÑ Atribui√ß√£o Autom√°tica', value: settings.autoAssign ? '‚úÖ Ativo' : '‚ùå Inativo', inline: true },
        { name: 'üìù Motivo Obrigat√≥rio', value: settings.requireReason ? '‚úÖ Sim' : '‚ùå N√£o', inline: true },
        { name: 'üë§ Tickets An√¥nimos', value: settings.allowAnonymous ? '‚úÖ Permitido' : '‚ùå N√£o Permitido', inline: true },
        { name: '‚è∞ Fechamento Autom√°tico', value: settings.closeAfterInactivity > 0 ? `${settings.closeAfterInactivity}h` : '‚ùå Desabilitado', inline: true }
      )
      .addFields(
        { name: 'üîî Notifica√ß√µes', value: '\u200B', inline: false },
        { name: 'üé´ Criar', value: settings.notificationSettings.onCreate ? '‚úÖ' : '‚ùå', inline: true },
        { name: 'üéØ Atribuir', value: settings.notificationSettings.onAssign ? '‚úÖ' : '‚ùå', inline: true },
        { name: 'üîí Fechar', value: settings.notificationSettings.onClose ? '‚úÖ' : '‚ùå', inline: true },
        { name: 'üîì Reabrir', value: settings.notificationSettings.onReopen ? '‚úÖ' : '‚ùå', inline: true }
      )
      .setTimestamp();

    if (settings.logChannelId) {
      embed.addFields({ name: 'üìã Canal de Logs', value: `<#${settings.logChannelId}>`, inline: true });
    }

    if (settings.supportRoleId) {
      embed.addFields({ name: 'üë• Cargo de Suporte', value: `<@&${settings.supportRoleId}>`, inline: true });
    }

    await interaction.editReply({ embeds: [embed] });
  } catch (error) {
    logger.error('Error viewing config:', error);
    
    const errorEmbed = new EmbedBuilder()
      .setTitle('‚ùå Erro')
      .setDescription('N√£o foi poss√≠vel carregar as configura√ß√µes.')
      .setColor('#FF0000');
    
    await interaction.editReply({ embeds: [errorEmbed] });
  }
}