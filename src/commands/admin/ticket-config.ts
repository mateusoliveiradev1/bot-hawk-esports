import {
  SlashCommandBuilder,
  ChatInputCommandInteraction,
  EmbedBuilder,
  PermissionFlagsBits,
  MessageFlags,
} from 'discord.js';
import { CommandCategory } from '../../types/command';
import { ExtendedClient } from '../../types/client';
import { BaseCommand } from '../../utils/base-command.util';
import { HawkEmbedBuilder } from '../../utils/hawk-embed-builder';

/**
 * Admin command to configure ticket system settings
 */
export class TicketConfigCommand extends BaseCommand {
  public data = new SlashCommandBuilder()
    .setName('ticket-config')
    .setDescription('Configurar sistema de tickets')
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator)
    .addSubcommand(subcommand =>
      subcommand
        .setName('timeout')
        .setDescription('Configurar tempo de inatividade para fechamento autom√°tico')
        .addIntegerOption(
          option =>
            option
              .setName('horas')
              .setDescription(
                'Horas de inatividade antes do fechamento autom√°tico (0 = desabilitar)'
              )
              .setRequired(true)
              .setMinValue(0)
              .setMaxValue(168) // 7 dias m√°ximo
        )
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('max-tickets')
        .setDescription('Configurar n√∫mero m√°ximo de tickets por usu√°rio')
        .addIntegerOption(option =>
          option
            .setName('quantidade')
            .setDescription('N√∫mero m√°ximo de tickets por usu√°rio')
            .setRequired(true)
            .setMinValue(1)
            .setMaxValue(10)
        )
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('auto-assign')
        .setDescription('Configurar atribui√ß√£o autom√°tica de tickets')
        .addBooleanOption(option =>
          option
            .setName('ativo')
            .setDescription('Ativar ou desativar atribui√ß√£o autom√°tica')
            .setRequired(true)
        )
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('require-reason')
        .setDescription('Configurar se motivo √© obrigat√≥rio para criar tickets')
        .addBooleanOption(option =>
          option
            .setName('obrigatorio')
            .setDescription('Tornar motivo obrigat√≥rio ou opcional')
            .setRequired(true)
        )
    )
    .addSubcommand(subcommand =>
      subcommand
        .setName('notifications')
        .setDescription('Configurar notifica√ß√µes do sistema de tickets')
        .addBooleanOption(option =>
          option
            .setName('criar')
            .setDescription('Notificar quando ticket for criado')
            .setRequired(false)
        )
        .addBooleanOption(option =>
          option
            .setName('atribuir')
            .setDescription('Notificar quando ticket for atribu√≠do')
            .setRequired(false)
        )
        .addBooleanOption(option =>
          option
            .setName('fechar')
            .setDescription('Notificar quando ticket for fechado')
            .setRequired(false)
        )
        .addBooleanOption(option =>
          option
            .setName('reabrir')
            .setDescription('Notificar quando ticket for reaberto')
            .setRequired(false)
        )
    )
    .addSubcommand(subcommand =>
      subcommand.setName('view').setDescription('Ver configura√ß√µes atuais do sistema de tickets')
    );

  public category = CommandCategory.ADMIN;
  public cooldown = 5;

  public async execute(interaction: ChatInputCommandInteraction, client: ExtendedClient) {
    let subcommand: string | undefined;

    try {
      // Validate interaction and client
      this.validateInteraction(interaction);
      this.validateClient(client);
      this.validateGuildContext(interaction);
      this.validateUserPermissions(interaction, [PermissionFlagsBits.Administrator]);

      // Validate required services
      const ticketService = client.services?.ticket;

      if (!ticketService) {
        await this.sendServiceUnavailableError(interaction, 'Ticket');
        return;
      }

      subcommand = interaction.options.getSubcommand();

      switch (subcommand) {
        case 'timeout':
          await this.handleTimeoutConfig(interaction, ticketService);
          break;
        case 'max-tickets':
          await this.handleMaxTicketsConfig(interaction, ticketService);
          break;
        case 'auto-assign':
          await this.handleAutoAssignConfig(interaction, ticketService);
          break;
        case 'require-reason':
          await this.handleRequireReasonConfig(interaction, ticketService);
          break;
        case 'notifications':
          await this.handleNotificationsConfig(interaction, ticketService);
          break;
        case 'view':
          await this.handleViewConfig(interaction, ticketService);
          break;
        default:
          throw new Error(`Unknown subcommand: ${subcommand}`);
      }
    } catch (error) {
      this.logger.error('Error in ticket-config command:', {
        userId: interaction.user.id,
        guildId: interaction.guildId,
        commandName: 'ticket-config',
        error,
        metadata: { subcommand },
      });

      const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';
      const embed = HawkEmbedBuilder.createErrorEmbed(
        'Erro no Comando de Configura√ß√£o de Tickets'
      ).setDescription(`Erro ao executar comando: ${errorMessage}`);

      await this.safeReply(interaction, { embeds: [embed] });
    }
  }

  /**
   * Handle timeout configuration
   */
  private async handleTimeoutConfig(interaction: ChatInputCommandInteraction, ticketService: any) {
    const horas = interaction.options.getInteger('horas', true);
    const guildId = interaction.guildId!;

    await this.deferWithLoading(interaction, true);

    try {
      const currentSettings = ticketService.getTicketSettings(guildId);
      const newSettings = {
        ...currentSettings,
        closeAfterInactivity: horas,
      };

      await ticketService.updateTicketSettings(guildId, newSettings);

      const embed = HawkEmbedBuilder.createSuccessEmbed('Configura√ß√£o Atualizada')
        .setDescription(
          horas === 0
            ? 'Fechamento autom√°tico por inatividade foi **desabilitado**.'
            : `Tickets ser√£o fechados automaticamente ap√≥s **${horas} horas** de inatividade.`
        )
        .addFields(
          {
            name: '‚è∞ Tempo Anterior',
            value: `${currentSettings.closeAfterInactivity}h`,
            inline: true,
          },
          { name: 'üÜï Novo Tempo', value: horas === 0 ? 'Desabilitado' : `${horas}h`, inline: true }
        )
        .setTimestamp();

      await this.safeReply(interaction, { embeds: [embed] });
    } catch (error) {
      throw new Error(
        `N√£o foi poss√≠vel atualizar a configura√ß√£o de timeout: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * Handle max tickets configuration
   */
  private async handleMaxTicketsConfig(
    interaction: ChatInputCommandInteraction,
    ticketService: any
  ) {
    const quantidade = interaction.options.getInteger('quantidade', true);
    const guildId = interaction.guildId!;

    await this.deferWithLoading(interaction, true);

    try {
      const currentSettings = ticketService.getTicketSettings(guildId);
      const newSettings = {
        ...currentSettings,
        maxTicketsPerUser: quantidade,
      };

      await ticketService.updateTicketSettings(guildId, newSettings);

      const embed = HawkEmbedBuilder.createSuccessEmbed('Configura√ß√£o Atualizada')
        .setDescription(`N√∫mero m√°ximo de tickets por usu√°rio definido para **${quantidade}**.`)
        .addFields(
          {
            name: 'üìä Limite Anterior',
            value: `${currentSettings.maxTicketsPerUser}`,
            inline: true,
          },
          { name: 'üÜï Novo Limite', value: `${quantidade}`, inline: true }
        )
        .setTimestamp();

      await this.safeReply(interaction, { embeds: [embed] });
    } catch (error) {
      throw new Error(
        `N√£o foi poss√≠vel atualizar a configura√ß√£o de limite de tickets: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * Handle auto assign configuration
   */
  private async handleAutoAssignConfig(
    interaction: ChatInputCommandInteraction,
    ticketService: any
  ) {
    const ativo = interaction.options.getBoolean('ativo', true);
    const guildId = interaction.guildId!;

    await this.deferWithLoading(interaction, true);

    try {
      const currentSettings = ticketService.getTicketSettings(guildId);
      const newSettings = {
        ...currentSettings,
        autoAssign: ativo,
      };

      await ticketService.updateTicketSettings(guildId, newSettings);

      const embed = HawkEmbedBuilder.createSuccessEmbed('Configura√ß√£o Atualizada')
        .setDescription(
          ativo
            ? 'Atribui√ß√£o autom√°tica de tickets foi **ativada**.'
            : 'Atribui√ß√£o autom√°tica de tickets foi **desativada**.'
        )
        .addFields(
          {
            name: 'üîÑ Status Anterior',
            value: currentSettings.autoAssign ? 'Ativo' : 'Inativo',
            inline: true,
          },
          { name: 'üÜï Novo Status', value: ativo ? 'Ativo' : 'Inativo', inline: true }
        )
        .setTimestamp();

      await this.safeReply(interaction, { embeds: [embed] });
    } catch (error) {
      throw new Error(
        `N√£o foi poss√≠vel atualizar a configura√ß√£o de atribui√ß√£o autom√°tica: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * Handle require reason configuration
   */
  private async handleRequireReasonConfig(
    interaction: ChatInputCommandInteraction,
    ticketService: any
  ) {
    const obrigatorio = interaction.options.getBoolean('obrigatorio', true);
    const guildId = interaction.guildId!;

    await this.deferWithLoading(interaction, true);

    try {
      const currentSettings = ticketService.getTicketSettings(guildId);
      const newSettings = {
        ...currentSettings,
        requireReason: obrigatorio,
      };

      await ticketService.updateTicketSettings(guildId, newSettings);

      const embed = HawkEmbedBuilder.createSuccessEmbed('Configura√ß√£o Atualizada')
        .setDescription(
          obrigatorio
            ? 'Motivo agora √© **obrigat√≥rio** para criar tickets.'
            : 'Motivo agora √© **opcional** para criar tickets.'
        )
        .addFields(
          {
            name: 'üìù Status Anterior',
            value: currentSettings.requireReason ? 'Obrigat√≥rio' : 'Opcional',
            inline: true,
          },
          { name: 'üÜï Novo Status', value: obrigatorio ? 'Obrigat√≥rio' : 'Opcional', inline: true }
        )
        .setTimestamp();

      await this.safeReply(interaction, { embeds: [embed] });
    } catch (error) {
      throw new Error(
        `N√£o foi poss√≠vel atualizar a configura√ß√£o de motivo obrigat√≥rio: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * Handle notifications configuration
   */
  private async handleNotificationsConfig(
    interaction: ChatInputCommandInteraction,
    ticketService: any
  ) {
    const criar = interaction.options.getBoolean('criar');
    const atribuir = interaction.options.getBoolean('atribuir');
    const fechar = interaction.options.getBoolean('fechar');
    const reabrir = interaction.options.getBoolean('reabrir');
    const guildId = interaction.guildId!;

    await this.deferWithLoading(interaction, true);

    try {
      const currentSettings = ticketService.getTicketSettings(guildId);
      const newNotificationSettings = {
        onCreate: criar !== null ? criar : currentSettings.notificationSettings.onCreate,
        onAssign: atribuir !== null ? atribuir : currentSettings.notificationSettings.onAssign,
        onClose: fechar !== null ? fechar : currentSettings.notificationSettings.onClose,
        onReopen: reabrir !== null ? reabrir : currentSettings.notificationSettings.onReopen,
      };

      const newSettings = {
        ...currentSettings,
        notificationSettings: newNotificationSettings,
      };

      await ticketService.updateTicketSettings(guildId, newSettings);

      const embed = HawkEmbedBuilder.createSuccessEmbed('Notifica√ß√µes Atualizadas')
        .setDescription('Configura√ß√µes de notifica√ß√£o foram atualizadas com sucesso.')
        .addFields(
          {
            name: 'üé´ Criar Ticket',
            value: newNotificationSettings.onCreate ? '‚úÖ Ativo' : '‚ùå Inativo',
            inline: true,
          },
          {
            name: 'üéØ Atribuir Ticket',
            value: newNotificationSettings.onAssign ? '‚úÖ Ativo' : '‚ùå Inativo',
            inline: true,
          },
          {
            name: 'üîí Fechar Ticket',
            value: newNotificationSettings.onClose ? '‚úÖ Ativo' : '‚ùå Inativo',
            inline: true,
          },
          {
            name: 'üîì Reabrir Ticket',
            value: newNotificationSettings.onReopen ? '‚úÖ Ativo' : '‚ùå Inativo',
            inline: true,
          }
        )
        .setTimestamp();

      await this.safeReply(interaction, { embeds: [embed] });
    } catch (error) {
      throw new Error(
        `N√£o foi poss√≠vel atualizar as configura√ß√µes de notifica√ß√£o: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * Handle view configuration
   */
  private async handleViewConfig(interaction: ChatInputCommandInteraction, ticketService: any) {
    const guildId = interaction.guildId!;

    await this.deferWithLoading(interaction, true);

    try {
      const settings = ticketService.getTicketSettings(guildId);

      const embed = HawkEmbedBuilder.createInfoEmbed('Configura√ß√µes do Sistema de Tickets')
        .setDescription('Configura√ß√µes atuais do sistema de tickets para este servidor.')
        .addFields(
          { name: 'üîß Sistema', value: settings.enabled ? '‚úÖ Ativo' : '‚ùå Inativo', inline: true },
          { name: 'üìä Max Tickets/Usu√°rio', value: `${settings.maxTicketsPerUser}`, inline: true },
          {
            name: 'üîÑ Atribui√ß√£o Autom√°tica',
            value: settings.autoAssign ? '‚úÖ Ativo' : '‚ùå Inativo',
            inline: true,
          },
          {
            name: 'üìù Motivo Obrigat√≥rio',
            value: settings.requireReason ? '‚úÖ Sim' : '‚ùå N√£o',
            inline: true,
          },
          {
            name: 'üë§ Tickets An√¥nimos',
            value: settings.allowAnonymous ? '‚úÖ Permitido' : '‚ùå N√£o Permitido',
            inline: true,
          },
          {
            name: '‚è∞ Fechamento Autom√°tico',
            value:
              settings.closeAfterInactivity > 0
                ? `${settings.closeAfterInactivity}h`
                : '‚ùå Desabilitado',
            inline: true,
          }
        )
        .addFields(
          { name: 'üîî Notifica√ß√µes', value: '\u200B', inline: false },
          {
            name: 'üé´ Criar',
            value: settings.notificationSettings.onCreate ? '‚úÖ' : '‚ùå',
            inline: true,
          },
          {
            name: 'üéØ Atribuir',
            value: settings.notificationSettings.onAssign ? '‚úÖ' : '‚ùå',
            inline: true,
          },
          {
            name: 'üîí Fechar',
            value: settings.notificationSettings.onClose ? '‚úÖ' : '‚ùå',
            inline: true,
          },
          {
            name: 'üîì Reabrir',
            value: settings.notificationSettings.onReopen ? '‚úÖ' : '‚ùå',
            inline: true,
          }
        )
        .setTimestamp();

      if (settings.logChannelId) {
        embed.addFields({
          name: 'üìã Canal de Logs',
          value: `<#${settings.logChannelId}>`,
          inline: true,
        });
      }

      if (settings.supportRoleId) {
        embed.addFields({
          name: 'üë• Cargo de Suporte',
          value: `<@&${settings.supportRoleId}>`,
          inline: true,
        });
      }

      await this.safeReply(interaction, { embeds: [embed] });
    } catch (error) {
      throw new Error(
        `N√£o foi poss√≠vel carregar as configura√ß√µes: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
}

// Export as default for compatibility
const commandInstance = new TicketConfigCommand();

const command = {
  data: commandInstance.data,
  category: commandInstance.category,
  cooldown: commandInstance.cooldown,
  execute: (interaction: ChatInputCommandInteraction, client: ExtendedClient) =>
    commandInstance.execute(interaction, client),
};

export default command;
