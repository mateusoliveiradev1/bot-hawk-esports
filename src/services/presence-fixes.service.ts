import { Logger } from '../utils/logger';
import { DatabaseService } from '../database/database.service';
import { ExtendedClient } from '../types/client';
import { PUBGService } from './pubg.service';
import { PresenceService } from './presence.service';

/**
 * Service to fix presence system issues and improve PUBG integration
 */
export class PresenceFixesService {
  private logger: Logger;
  private database: DatabaseService;
  private pubgService: PUBGService;
  private presenceService: PresenceService;

  constructor(client: ExtendedClient) {
    this.logger = new Logger();
    this.database = client.database;
    this.pubgService = client.pubgService;
    this.presenceService = client.presenceService;
  }

  /**
   * Fix presence data inconsistencies
   */
  public async fixPresenceDataInconsistencies(): Promise<void> {
    try {
      this.logger.info('Starting presence data consistency fixes...');

      // Fix 1: Remove orphaned check-ins without corresponding check-outs
      await this.fixOrphanedCheckIns();

      // Fix 2: Fix sessions with invalid durations
      await this.fixInvalidSessionDurations();

      // Fix 3: Standardize presence types
      await this.standardizePresenceTypes();

      // Fix 4: Clean up duplicate sessions
      await this.cleanupDuplicateSessions();

      this.logger.info('Presence data consistency fixes completed');
    } catch (error) {
      this.logger.error('Error fixing presence data inconsistencies:', error);
      throw error;
    }
  }

  /**
   * Fix orphaned check-ins without corresponding check-outs
   */
  private async fixOrphanedCheckIns(): Promise<void> {
    try {
      // Find check-ins older than 24 hours without check-outs
      const cutoffTime = new Date();
      cutoffTime.setHours(cutoffTime.getHours() - 24);

      const orphanedCheckIns = await this.database.client.presence.findMany({
        where: {
          type: 'checkin',
          checkInTime: {
            lt: cutoffTime,
          },
        },
      });

      for (const checkIn of orphanedCheckIns) {
        // Check if there's a corresponding checkout
        const checkout = await this.database.client.presence.findFirst({
          where: {
            userId: checkIn.userId,
            guildId: checkIn.guildId,
            type: 'checkout',
            timestamp: {
              gt: checkIn.timestamp,
            },
          },
        });

        if (!checkout) {
          // Create automatic checkout
          const autoCheckoutTime = new Date(checkIn.timestamp);
          autoCheckoutTime.setHours(autoCheckoutTime.getHours() + 12); // Auto checkout after 12 hours

          await this.database.client.presence.create({
            data: {
              userId: checkIn.userId,
              guildId: checkIn.guildId,
              type: 'checkout',
              checkOutTime: autoCheckoutTime,
              note: 'Auto checkout - sistema de correção',
              metadata: JSON.stringify({
                checkInId: checkIn.id,
                autoGenerated: true,
              }),
            },
          });

          this.logger.info(`Created auto checkout for orphaned check-in: ${checkIn.id}`);
        }
      }
    } catch (error) {
      this.logger.error('Error fixing orphaned check-ins:', error);
      throw error;
    }
  }

  /**
   * Fix sessions with invalid durations (negative or extremely long)
   */
  private async fixInvalidSessionDurations(): Promise<void> {
    try {
      const presences = await this.database.client.presence.findMany({
        where: {
          type: 'checkout',
          checkOutTime: {
            not: null,
          },
        },
        include: {
          user: true,
        },
      });

      for (const checkout of presences) {
        if (!checkout.checkOutTime) {
          continue;
        }

        // Find corresponding check-in
        const checkin = await this.database.client.presence.findFirst({
          where: {
            userId: checkout.userId,
            guildId: checkout.guildId,
            type: 'checkin',
            timestamp: {
              lt: checkout.timestamp,
            },
          },
          orderBy: {
            timestamp: 'desc',
          },
        });

        if (checkin && checkin.checkInTime) {
          const duration = checkout.checkOutTime.getTime() - checkin.checkInTime.getTime();
          const durationHours = duration / (1000 * 60 * 60);

          // Fix sessions longer than 24 hours or negative durations
          if (durationHours > 24 || durationHours < 0) {
            // Cap session at 12 hours maximum
            const correctedCheckoutTime = new Date(checkin.checkInTime);
            correctedCheckoutTime.setHours(correctedCheckoutTime.getHours() + 12);

            await this.database.client.presence.update({
              where: { id: checkout.id },
              data: {
                checkOutTime: correctedCheckoutTime,
                note: (checkout.note || '') + ' [Duração corrigida pelo sistema]',
              },
            });

            this.logger.info(`Fixed invalid session duration for user ${checkout.userId}`);
          }
        }
      }
    } catch (error) {
      this.logger.error('Error fixing invalid session durations:', error);
      throw error;
    }
  }

  /**
   * Standardize presence types (checkin/checkout vs check_in/check_out)
   */
  private async standardizePresenceTypes(): Promise<void> {
    try {
      // Update old format to new format
      await this.database.client.presence.updateMany({
        where: { type: 'check_in' },
        data: { type: 'checkin' },
      });

      await this.database.client.presence.updateMany({
        where: { type: 'check_out' },
        data: { type: 'checkout' },
      });

      this.logger.info('Standardized presence types');
    } catch (error) {
      this.logger.error('Error standardizing presence types:', error);
      throw error;
    }
  }

  /**
   * Clean up duplicate sessions
   */
  private async cleanupDuplicateSessions(): Promise<void> {
    try {
      // Find users with multiple active check-ins
      const duplicateCheckIns = await this.database.client.presence.groupBy({
        by: ['userId', 'guildId'],
        where: {
          type: 'checkin',
        },
        having: {
          userId: {
            _count: {
              gt: 1,
            },
          },
        },
      });

      for (const group of duplicateCheckIns) {
        const checkIns = await this.database.client.presence.findMany({
          where: {
            userId: group.userId,
            guildId: group.guildId,
            type: 'checkin',
          },
          orderBy: {
            timestamp: 'desc',
          },
        });

        // Keep the most recent check-in, remove others
        const [latest, ...duplicates] = checkIns;

        for (const duplicate of duplicates) {
          // Check if this check-in has a corresponding checkout
          const hasCheckout = await this.database.client.presence.findFirst({
            where: {
              userId: duplicate.userId,
              guildId: duplicate.guildId,
              type: 'checkout',
              timestamp: {
                gt: duplicate.timestamp,
              },
            },
          });

          if (!hasCheckout) {
            // Safe to delete as it's a true duplicate
            await this.database.client.presence.delete({
              where: { id: duplicate.id },
            });
            this.logger.info(`Removed duplicate check-in: ${duplicate.id}`);
          }
        }
      }
    } catch (error) {
      this.logger.error('Error cleaning up duplicate sessions:', error);
      throw error;
    }
  }

  /**
   * Enhance PUBG integration for presence system
   */
  public async enhancePUBGIntegration(): Promise<void> {
    try {
      this.logger.info('Enhancing PUBG integration for presence system...');

      // Get users with PUBG usernames
      const pubgUsers = await this.database.client.user.findMany({
        where: {
          pubgUsername: {
            not: null,
          },
        },
      });

      for (const user of pubgUsers) {
        if (user.pubgUsername && user.pubgPlatform) {
          try {
            // Validate PUBG username exists
            const playerData = await this.pubgService.getPlayerByName(
              user.pubgUsername,
              user.pubgPlatform as any,
            );

            if (!playerData) {
              this.logger.warn(`Invalid PUBG username for user ${user.id}: ${user.pubgUsername}`);
              continue;
            }

            // PUBG username is valid - no additional update needed as pubgPlayerId field doesn't exist in schema
            this.logger.info(`Validated PUBG username for user ${user.id}: ${user.pubgUsername}`);
          } catch (error) {
            this.logger.error(`Error validating PUBG data for user ${user.id}:`, error);
          }
        }
      }

      this.logger.info('PUBG integration enhancement completed');
    } catch (error) {
      this.logger.error('Error enhancing PUBG integration:', error);
      throw error;
    }
  }

  /**
   * Optimize presence service performance
   */
  public async optimizePresencePerformance(): Promise<void> {
    try {
      this.logger.info('Optimizing presence service performance...');

      // Clean up old presence records (older than 6 months)
      const sixMonthsAgo = new Date();
      sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

      const deletedCount = await this.database.client.presence.deleteMany({
        where: {
          timestamp: {
            lt: sixMonthsAgo,
          },
        },
      });

      this.logger.info(`Cleaned up ${deletedCount.count} old presence records`);

      // Update user stats cache
      await this.updateUserStatsCache();

      this.logger.info('Presence service performance optimization completed');
    } catch (error) {
      this.logger.error('Error optimizing presence performance:', error);
      throw error;
    }
  }

  /**
   * Update user stats cache
   */
  private async updateUserStatsCache(): Promise<void> {
    try {
      const users = await this.database.client.user.findMany({
        include: {
          stats: true,
        },
      });

      for (const user of users) {
        // Calculate total voice time from presence records
        const presences = await this.database.client.presence.findMany({
          where: {
            userId: user.id,
            type: 'checkout',
            checkOutTime: {
              not: null,
            },
          },
        });

        let totalVoiceTime = 0;
        for (const presence of presences) {
          if (presence.checkOutTime) {
            // Find corresponding check-in
            const checkin = await this.database.client.presence.findFirst({
              where: {
                userId: user.id,
                guildId: presence.guildId,
                type: 'checkin',
                timestamp: {
                  lt: presence.timestamp,
                },
              },
              orderBy: {
                timestamp: 'desc',
              },
            });

            if (checkin && checkin.checkInTime) {
              const duration = presence.checkOutTime.getTime() - checkin.checkInTime.getTime();
              totalVoiceTime += Math.floor(duration / 1000); // Convert to seconds
            }
          }
        }

        // Update user stats
        await this.database.client.userStats.upsert({
          where: { userId: user.id },
          update: {
            voiceTime: totalVoiceTime,
          },
          create: {
            userId: user.id,
            voiceTime: totalVoiceTime,
          },
        });
      }
    } catch (error) {
      this.logger.error('Error updating user stats cache:', error);
      throw error;
    }
  }

  /**
   * Run all presence system fixes
   */
  public async runAllFixes(): Promise<void> {
    try {
      this.logger.info('Running all presence system fixes...');

      await this.fixPresenceDataInconsistencies();
      await this.enhancePUBGIntegration();
      await this.optimizePresencePerformance();

      this.logger.info('All presence system fixes completed successfully');
    } catch (error) {
      this.logger.error('Error running presence system fixes:', error);
      throw error;
    }
  }
}
